{
  "api/Microsoft.DocAsCode.Docset.html": {
    "href": "api/Microsoft.DocAsCode.Docset.html",
    "title": "Class Docset | docfx",
    "keywords": "Class Docset Provides access to a set of documentations and their associated configs, compilations and models. Inheritance Object Docset Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : Microsoft.DocAsCode Assembly : Microsoft.DocAsCode.App.dll Syntax public static class Docset Methods | Improve this Doc View Source Build(String) Builds a docset specified by docfx.json config. Declaration public static Task Build(string configPath) Parameters Type Name Description String configPath The path to docfx.json config file. Returns Type Description Task A task to await for build completion."
  },
  "api/Microsoft.DocAsCode.html": {
    "href": "api/Microsoft.DocAsCode.html",
    "title": "Namespace Microsoft.DocAsCode | docfx",
    "keywords": "Namespace Microsoft.DocAsCode Classes Docset Provides access to a set of documentations and their associated configs, compilations and models."
  },
  "docs/config.html": {
    "href": "docs/config.html",
    "title": "Config | docfx",
    "keywords": "Config Docfx uses docfx.json as the config file for the site. Most docfx commands operate in a directory containing docfx.json . The build config determines what files are included in the site: { \"build\": { \"content\": [ { \"files\": \"**/*.{md,yml}\", \"exclude\": \"**/include/**\" } ], \"resource\": [ { \"files\": \"**/images/**\" } ] } } The content config defines glob patterns of files that are transformed to HTML by the build process. It is usually the markdown files and auto-generated API YAML files. The resource config defines static resources copied to output as is. URL Management URL is determined by the file path relative to docfx.json . Docfx uses “Ugly URLs”: a file named docs/urls.md is accessible from the docs/urls.html URL. To customize URL pattern for a directory, use the src property to remove the directory name from the URL, and use the dest property to insert an URL prefix: { \"build\": { \"content\": [ { \"files\": \"**/*.{md,yml}\", \"src\": \"articles\", \"dest\": \"docs\" } ] } } In this example, files in the articles directory uses docs as the base URL: The articles/getting-started/installation.md file is accessible by the docs/getting-started/installation.html URL. Metadata Metadata are attributes attached to an file. It helps shape the look and feel of a page and provides extra context to the article. To add metadata to an article, use \"YAML Front Matter\" markdown extension syntax: --- title: a title description: a description --- Some metadata attributes are consistent across a set of content. Use the globalMetadata property in docfx.json to apply the same metadata to all articles: { \"build\": { \"globalMetadata\": { \"_appTitle\": \"My App\" } } } To apply identical metadata values to a folder or a set of content, use the fileMetadata config: { \"build\": { \"fileMetadata\": { \"_appTitle\": { \"articles/dotnet/**/*.md\": \".NET\", \"articles/typescript/**/*.md\": \"TypeScript\" } } } } When the same metadata key is defined in multiple places, YAML Front Matter takes precedence over fileMetadata which in turn takes precedence over globalMetadata . Predefined Metadata Here is a list of predefined metadata recognized by the default docfx site template to customize basic site settings: Name Type Description _appTitle string A string append to every page title. _appFooter string The footer HTML. _appLogoPath string App logo URL path. _appFaviconPath string Favicon URL path. _enableSearch bool Whether to show the search box. _enableNewTab bool Whether to open external links in a new tab. _disableNavbar bool Whether to show the navigation bar. _disableBreadcrumb bool Whether to show the breadcrumb. _disableToc bool Whether to show the TOC. _disableAffix bool Whether to show the right rail. _noindex bool Whether to include in search results _disableContribution bool Whether to show the \"Improve this Doc\" and _\"View Source\" buttons. _gitContribute object Defines the repo and branch property of git links. _gitUrlPattern string URL pattern of git links. Tip Docfx produces the right git links for major CI pipelines including GitHub , GitLab , Azure Pipelines , AppVeyor , TeamCity , Jenkins . _gitContribute and _gitUrlPattern are optional on these platforms. Sitemap Docfx produces a sitemap.xml about the pages on your site for search engines like Google to crawl your site more efficiently. The sitemap option in docfx.json controls how sitemaps are generated: { \"build\": { \"sitemap\": { \"baseUrl\": \"https://dotnet.github.iodocfx\", \"priority\": 0.1, \"changefreq\": \"monthly\" } } } Where: baseUrl is the base URL for the website. It should start with http or https and end with a trailing slash. For example, https://dotnet.github.io/docfx/ . lastmod is the date of last modification of the page. If not specified, docfx sets the date to the build time. changefreq determines how frequently the page is likely to change. Valid values are always , hourly , daily , weekly , monthly , yearly , never . Default to daily . priority is the priority of this URL relative to other URLs on your site. Valid values range from 0.0 to 1.0. fileOptions is a per file config of the above options. The key is the file glob pattern and value is the sitemap options."
  },
  "docs/dotnet-api-docs.html": {
    "href": "docs/dotnet-api-docs.html",
    "title": ".NET API Docs | docfx",
    "keywords": ".NET API Docs Docfx converts XML documentation comments into rendered HTML documentations. Build from DLL, csproj or Source Code To add API docs for a .NET project, add a metadata section before the build section in docfx.json config: { \"metadata\": { \"src\": [{ \"files\": [\"**/bin/Release/**.dll\"], \"src\": \"../\" }], \"dest\": \"api\" }, \"build\": { \"content\": [{ \"files\": [ \"**/*.{md,yml}\" ] }] } } The docfx metadata command uses metadata config to produce .NET API YAML files at the dest directory for the docfx build command to turn into HTML files. The src property can be a glob pattern of DLL, csproj, or source code. When file extension is .dll , docfx produces API docs using the DLL and the side-by-side XML documentation file. Source code linking is not available in this mode. When file extension is .csproj , .vbproj , .fsproj or .sln , docfx builds the project and produces API docs based on project config and source code. Source code linking is available in this mode. Additional msbuild properties to build the projects can be specified in the properties config: { \"metadata\": { \"src\": [{ \"files\": [\"**/bin/Release/**.dll\"], \"src\": \"../\" }], \"dest\": \"api\", \"properties\": { \"TargetFramework\": \"net6.0\" } }, } When file extension is .cs or .vb , docfx uses the latest .NET Core SDK installed on the machine to build the source code. References provided by Microsoft.NET.Sdk are available to the source code, additional references can be specified in the references config: { \"metadata\": { \"src\": [{ \"files\": [\"**/bin/Release/**.dll\"], \"src\": \"../\" }], \"dest\": \"api\", \"references\": [ \"path-to-my-library.dll\" ] }, } Supported XML Tags Docfx supports Recommended XML tags for C# documentation comments . Warning Docfx parses XML documentation comment as markdown by default, writing XML documentation comments using markdown may cause rendering problems on places that do not support markdown, like in the Visual Studio intellisense window. To disable markdown parsing while processing XML tags, set shouldSkipMarkup to true : { \"metadata\": { \"src\": [{ \"files\": [\"**/bin/Release/**.dll\"], \"src\": \"../\" }], \"dest\": \"api\", \"shouldSkipMarkup\": true } } Filter APIs Docfx hides generated code or members marked as [EditorBrowsableAttribute] from API docs using filters. The default filter config contains common API patterns to exclude from docs. To add additional filter rules, add a custom YAML file and set the filter property in docfx.json to point to the custom YAML filter: { \"metadata\": { \"src\": [{ \"files\": [\"**/bin/Release/**.dll\"], \"src\": \"../\" }], \"dest\": \"api\", \"filter\": \"filterConfig.yml\" // <-- Path to custom filter config } } The filter config is a list of rules. A rule can include or exclude a set of APIs based on a pattern. The rules are processed sequentially and would stop when a rule matches. Filter by UID Every item in the generated API docs has a UID (a unique identifier calculated for each API) to filter against using regular expression. This example uses uidRegex to excludes all APIs whose uids start with Microsoft.DevDiv but not Microsoft.DevDiv.SpecialCase . apiRules: - include: uidRegex: ^Microsoft\\.DevDiv\\.SpecialCase - exclude: uidRegex: ^Microsoft\\.DevDiv Filter by Type This example exclude APIs whose uid starts with Microsoft.DevDiv and type is Type : apiRules: - exclude: uidRegex: ^Microsoft\\.DevDiv type: Type Supported value for type are: Namespace Class Struct Enum Interface Delegate Event Field Method Property Type : a Class , Struct , Enum , Interface or Delegate . Member : a Field , Event , Method or Property . API filter are hierarchical, if a namespace is excluded, all types/members defined in the namespace would also be excluded. Similarly, if a type is excluded, all members defined in the type would also be excluded. Filter by Attribute This example excludes all APIs which have AttributeUsageAttribute set to System.AttributeTargets.Class and the Inherited argument set to true : apiRules: - exclude: hasAttribute: uid: System.AttributeUsageAttribute ctorArguments: - System.AttributeTargets.Class ctorNamedArguments: Inherited: \"true\" Where the ctorArguments property specifies a list of match conditions based on constructor parameters and the ctorNamedArguments property specifies match conditions using named constructor arguments."
  },
  "docs/dotnet-yaml-format.html": {
    "href": "docs/dotnet-yaml-format.html",
    "title": ".NET API Docs YAML Format | docfx",
    "keywords": ".NET API Docs YAML Format This document describes the YAML file format to represent .NET API docs. The first line of the YAML file is the magic header ### YamlMime:ManagedReference . 1. Items The following .NET elements are defined as items in metadata: Namespaces Types, including class, struct, interface, enum, delegate Type members, including field, property, method, event Other elements such as parameters and generic parameters are not standalone items , they're part of other items . 2. Identifiers 2.1 Unique Identifiers For any item in .NET languages, its UID is defined by concatenating its parent 's UID and its own ID with a dot. The ID for each kind of item is defined in following sections. The basic principle here is to make ID format close to source code and easy for human reading. UID is similar to the document comment id, which is started with type prefix, for example, T: , or M: , but UID do not. There MUST NOT be any whitespace between method name, parentheses, parameters, and commas. 2.2 Spec Identifiers Spec identifier is another form of UID . It can spec a generic type with type arguments (for example, for parameters, return types or inheritances) and these UID s are unique in one yaml file. It is a simple modified Unique Identifiers, when it contains generic type arguments, it will use {Name} instead `N . For type parameter, it will be {Name} . And it also supports array and pointer. Example 2.2 Spec Identifier C#: namespace Foo { public class Bar { public unsafe List<String> FooBar<TArg>(int[] arg1, byte* arg2, TArg arg3, List<TArg[]> arg4) { return null; } } } YAML: references: - uid: System.Collections.Generic.List{System.String} - uid: System.Int32[] - uid: System.Byte* - uid: {TArg} - uid: System.Collections.Generic.List{{TArg}[]} 3. Namespaces For all namespaces, they are flat, e.i. namespaces do not have the parent namespace. So for any namespace, ID is always same with its UID . Example 3 Namespace C#: namespace System.IO { } YAML: uid: System.IO id: System.IO name: System.IO fullName: System.IO The children of namespace are all the visible types in the namespace. 4. Types Types include classes, structs, interfaces, enums, and delegates. They have following properties: summary, remarks, syntax, namespace, assemblies, inheritance. The parents of types are namespaces. The children of types are members. ID ID for a type is also its name . Example 4 Type C#: namespace System { public class String {} public struct Boolean {} public interface IComparable {} public enum ConsoleColor {} public delegate void Action(); } YAML: - uid: System.String id: String name.csharp: String fullName.csharp: System.String - uid: System.Boolean id: Boolean name.csharp: Boolean fullName.csharp: System.String - uid: System.IComparable id: IComparable name.csharp: IComparable fullName.csharp: System.IComparable - uid: System.ConsoleColor id: ConsoleColor name.csharp: ConsoleColor fullName.csharp: System.ConsoleColor - uid: System.Action id: Action name.csharp: Action fullName.csharp: System.Action 4.1 ID for Nested Types For nested types, ID is defined by concatenating the ID of all its containing types and the ID of itself, separated by a dot. The parent type of a nested type is its containing namespace, rather than its containing type. Example 4.1 Nested type C#: namespace System { public class Environment { public enum SpecialFolder {} } } YAML: uid: System.Environment.SpecialFolder id: Environment.SpecialFolder name.csharp: Environment.SpecialFolder fullName.csharp: System.Environment.SpecialFolder 4.2 Inheritance Only class contains inheritance, and the inheritance is a list of spec id. Example 4.2 Inheritance C#: namespace System.Collections.Generic { public class KeyedByTypeCollection<TItem> : KeyedCollection<Type, TItem> { } } YAML: uid : System.Collections.Generic.KeyedByTypeCollection`1 inheritance: - System.Collections.ObjectModel.KeyedCollection{System.Type,{TItem}} - System.Collections.ObjectModel.Collection{{TItem}} - System.Object 4.3 Syntax The syntax part for type contains declaration, and descriptions of type parameters for different languages. For delegates, it also contains descriptions of parameters and a return type. 5. Members Members include fields, properties, methods, and events. They have the following properties: summary, remarks, exceptions, and syntax. The parents of members are types. Members never have children, and all parameter types or return types are spec id. 5.1 Constructors The ID of a constructor is defined by #ctor , followed by the list of the UIDs of its parameter types: When a constructor does not have parameter, its ID MUST NOT end with parentheses. The syntax part for constructors contains a special language declaration, and descriptions of parameters. Example 5.1 Constructor C#: namespace System { public sealed class String { public String(); public String(char[] chars); } } YAML: - uid: System.String.#ctor id: #ctor name.csharp: String() fullName.csharp: System.String.String() - uid: System.String.#ctor(System.Char[]) id: #ctor(System.Char[]) name.csharp: String(Char[]) fullName.csharp: System.String.String(System.Char[]) 5.2 Methods The ID of a method is defined by its name, followed by the list of the UIDs of its parameter types: method_name(param1,param2,...) When a method does not have parameter, its ID MUST end with parentheses. The syntax part for method contains a special language declaration, and descriptions of type parameters for generic method, descriptions of parameters and return type. Example 5.2 Method C#: namespace System { public sealed class String { public String ToString(); public String ToString(IFormatProvider provider); } } YAML: - uid: System.String.ToString id: ToString name.csharp: ToString() fullName.csharp: System.String.ToString() - uid: System.String.ToString(System.IFormatProvider) id: ToString(System.IFormatProvider) name.csharp: ToString(IFormatProvider) fullName.csharp: System.String.ToString(System.IFormatProvider) 5.2.1 Explicit Interface Implementation The ID of an explicit interface implementation (EII) member MUST be prefixed by the UID of the interface it implements and replace . to # . Example 2.6 Explicit interface implementation (EII) C#: namespace System { using System.Collections; public sealed class String : IEnumerable { IEnumerator IEnumerable.GetEnumerator(); } } YAML: - uid: \"System.String.System#Collections#IEnumerable#GetEnumerator\" id: \"System#Collections#IEnumerable#GetEnumerator\" name.csharp: IEnumerable.GetEnumerator() fullName.csharp: System.String.System.Collections.IEnumerable.GetEnumerator() 5.4 Operator Overloads The IDs of operator overloads are same with the metadata name (for example, op_Equality ). The names of operator overloads are similar to MSDN, just remove op_ from the metadata name of the method. For instance, the name of the equals ( == ) operator is Equality . Type conversion operator can be considered a special operator whose name is the UID of the target type, with one parameter of the source type. For example, an operator that converts from string to int should be Explicit(System.String to System.Int32) . The syntax part for methods contains a special language declaration, descriptions of parameters and return type. Example 5.4 Operator overload namespace System { public struct Decimal { public static implicit operator Decimal(Char value); } public sealed class String { public static bool operator ==(String a, String b); } } YAML: - uid: System.Decimal.op_Implicit(System.Char)~System.Decimal id: op_Implicit(System.Char)~System.Decimal name.csharp: Implicit(Char to Decimal) fullName.csharp: System.Decimal.Implicit(System.Char to System.Decimal) - uid: System.String.op_Equality(System.String,System.String) id: op_Equality(System.String,System.String) name.csharp: Equality(String,String) fullName.csharp: System.String.Equality(System.String,System.String) Please check overloadable operators for all overloadable operators. 5.5 Field, Property or Event The ID of field, property or event is its name. The syntax part for field contains a special language declaration and descriptions of field type. For property, it contains a special language declaration, descriptions of parameters, and return type. For event, it contains a special language declaration and descriptions of event handler type. Example 5.5 Field, Property and Event C#: namespace System { public sealed class String { public static readonly String Empty; public int Length { get; } } public static class Console { public static event ConsoleCancelEventHandler CancelKeyPress; } } YAML: - uid: System.String.Empty id: Empty name.csharp: Empty fullName.csharp: System.String.Empty - uid: System.String.Length id: Length name.csharp: Length fullName.csharp: System.String.Length - uid: System.Console.CancelKeyPress id: CancelKeyPress name.csharp: CancelKeyPress fullName.csharp: System.Console.CancelKeyPress 5.6 Indexer Indexer operator's name is metadata name, by default, it is Item , with brackets and parameters. Example 5.6 Indexer namespace System.Collections { public interface IList { object this[int index] { get; set; } } } YAML: - uid: \"System.Collections.IList.Item[System.Int32]\" id: \"Item[System.Int32]\" name.csharp: Item[Int32] fullName.csharp: System.Collections.IList.Item[System.Int32] 6. Generics The ID of a generic type is its name with followed by `n , n and the count of generic type count, which is the same as the rule for document comment ID. For example, Dictionary`2 . The ID of a generic method uses postfix ``n , n is the count of in method parameters, for example, System.Tuple.Create``1(``0) . Example 2.7 Generic namespace System { public static class Tuple { public static Tuple<T1> Create<T1>(T1 item1); public static Tuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2); } } YAML: - uid: System.Tuple.Create``1(``0) id: Create``1(``0) name.csharp: Create<T1>(T1) fullName.csharp: System.Tuple.Create<T1>(T1) - uid: System.Tuple.Create``2(``0,``1) id: Create``2(``0,``1) name.csharp: Create<T1,T2>(T1,T2) fullName.csharp: System.Tuple.Create<T1,T2>(T1,T2) 7. Reference The reference contains the following members: name, fullName, summary, isExternal, href, and more. The UID in reference can be a Spec Id , then it contains one more member: spec. The spec in reference is very like a list of lightweight references, it describes how to compose the generic type in some special language. Example 7 spec for references YAML: references: - uid: System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{System.Int32}} name.csharp: Dictionary<String, List<Int32>> fullName.csharp: System.Collections.Generic.Dictionary<System.String, System.Collections.Generic.List<System.Int32>> spec.csharp: - uid: System.Collections.Generic.Dictionary`2 name: Dictionary fullName: System.Collections.Generic.Dictionary isExternal: true - name: < fullName: < - uid: System.String name: String fullName: System.String isExternal: true - name: ', ' fullName: ', ' - uid: System.Collections.Generic.List`1 name: List fullName: System.Collections.Generic.List isExternal: true - name: < fullName: < - uid: System.Int32 name: Int32 fullName: System.Int32 isExternal: true - name: '>' fullName: '>' - name: '>' fullName: '>'"
  },
  "docs/markdown.html": {
    "href": "docs/markdown.html",
    "title": "Markdown | docfx",
    "keywords": "Markdown Markdown is a lightweight markup language with plain text formatting syntax. Docfx supports CommonMark compliant Markdown parsed through the Markdig parsing engine. Docfx supports additional markdown syntax that provide richer content. These syntax are specific to docfx and won't be rendered elsewhere like GitHub. Alerts Alerts are block quotes that render with colors and icons that indicate the significance of the content. The following alert types are supported: > [!NOTE] > Information the user should notice even if skimming. > [!TIP] > Optional information to help a user be more successful. > [!IMPORTANT] > Essential information required for user success. > [!CAUTION] > Negative potential consequences of an action. > [!WARNING] > Dangerous certain consequences of an action. They look like this in rendered page: Note Information the user should notice even if skimming. Tip Optional information to help a user be more successful. Important Essential information required for user success. Caution Negative potential consequences of an action. Warning Dangerous certain consequences of an action. Video You can embed a video in your page by using the following Markdown syntax: > [!Video embed_link] Example: > [!Video https://www.youtube.com/embed/Sz1lCeedcPI] This will be rendered as: Include Markdown Files Where markdown files need to be repeated in multiple articles, you can use an include file. The includes feature replace the reference with the contents of the included file at build time. You can reuse a common text snippet within a sentence using inline include: Text before [!INCLUDE [<title>](<filepath>)] and after. Or reuse an entire Markdown file as a block, nested within a section of an article. Block include is on its own line: [!INCLUDE [<title>](<filepath>)] Where <title> is the name of the file and <filepath> is the relative path to the file. Included markdown files needs to be excluded from build, they are usually placed in the /includes folder. Code Snippet There are several ways to include code in an article. The code snippet syntax replaces code from another file: [!code-csharp[](Program.cs)] You can include selected lines from the code snippet using region or line range syntax: [!code-csharp[](Program.cs#region)] [!code-csharp[](Program.cs#L12-L16)] Code snippets are indicated by using a specific link syntax described as follows: [!code-<language>[](<filepath><query-options>)] Where <language> is the syntax highlighting language of the code and <filepath> is the relative path to the markdown file. Highlight Selected Lines Code Snippets typically include more code than necessary in order to provide context. It helps readability when you highlight the key lines that you're focusing on. To highlight key lines, use the highlight query options: [!code-csharp[](Program.cs?highlight=2,5-7,9-)] The example highlights lines 2, line 5 to 7 and lines 9 to the end of the file. Tabs Tabs enable content that is multi-faceted. They allow sections of a document to contain variant content renderings and eliminates duplicate content. Here's an example of the tab experience: Linux Windows Content for Linux... Content for Windows... The above tab group was created with the following syntax: # [Linux](#tab/linux) Content for Linux... # [Windows](#tab/windows) Content for Windows... --- Tabs are indicated by using a specific link syntax within a Markdown header. The syntax can be described as follows: # [Tab Display Name](#tab/tab-id) A tab starts with a Markdown header, # , and is followed by a Markdown link []() . The text of the link will become the text of the tab header, displayed to the customer. In order for the header to be recognized as a tab, the link itself must start with #tab/ and be followed by an ID representing the content of the tab. The ID is used to sync all same-ID tabs across the page. Using the above example, when a user selects a tab with the link #tab/windows , all tabs with the link #tab/windows on the page will be selected. Dependent tabs It's possible to make the selection in one set of tabs dependent on the selection in another set of tabs. Here's an example of that in action: .NET .NET TypeScript TypeScript REST API .NET content for Linux... .NET content for Windows... TypeScript content for Linux... TypeScript content for Windows... REST API content, independent of platform... Notice how changing the Linux/Windows selection above changes the content in the .NET and TypeScript tabs. This is because the tab group defines two versions for each .NET and TypeScript, where the Windows/Linux selection above determines which version is shown for .NET/TypeScript. Here's the markup that shows how this is done: # [.NET](#tab/dotnet/linux) .NET content for Linux... # [.NET](#tab/dotnet/windows) .NET content for Windows... # [TypeScript](#tab/typescript/linux) TypeScript content for Linux... # [TypeScript](#tab/typescript/windows) TypeScript content for Windows... # [REST API](#tab/rest) REST API content, independent of platform... ---"
  },
  "docs/pdf.html": {
    "href": "docs/pdf.html",
    "title": "Create PDF Files | docfx",
    "keywords": "Create PDF Files Docfx produces PDF files based on the TOC structure. Install wkhtmltopdf To build PDF files, first install wkhtmltopdf by downloading the latest binary from the official site or install using chocolatey: choco install wkhtmltopdf . Make sure the wkhtmltopdf command is added to PATH environment variable and is available in the terminal. PDF Config Add a pdf section in docfx.json : { \"pdf\": { \"content\": [{ \"files\": [ \"**/*.{md,yml}\" ] }], \"wkhtmltopdf\": { \"additionalArguments\": \"--enable-local-file-access\" }, } } Most of the config options are the same as build config. The wkhtmltopdf config contains additional details to control wkhtmltopdf behavior: filePath : Path to wkhtmltopdf.exe . additionalArguments : Additional command line arguments passed to wkhtmltopdf . Usually needs --enable-local-file-access to allow access to local files. Running docfx command againt the above configuration produces a PDF file for every TOC included in the content property. The PDF files are placed under the _site_pdf folder based on the TOC name. See this sample on an example PDF config. Add Cover Page A cover page is the first PDF page before the TOC page. To add a cover page, add a cover.md file alongside toc.yml . The content of cover.md will be rendered as the PDF cover page."
  },
  "docs/rest-api-docs.html": {
    "href": "docs/rest-api-docs.html",
    "title": "Add REST API docs | docfx",
    "keywords": "Add REST API docs Docfx generates REST API documentation from Swagger 2.0 files. To add REST API docs, include the swagger JSON file to the build config in docfx.json : { \"metadata\": { \"src\": [ \"../src/**/bin/Release/**.dll\" ], \"dest\": \"api\" }, \"build\": { \"content\": [{ \"files\": [ \"**/*.swagger.json\" ] // <-- Include swagger JSON files }] } } Each swagger file produces one output HTML file. Organize REST APIs using Tags APIs can be organized using the Tag Object . An API can be associated with one or more tags. Untagged APIs are put in the Other apis section. This example defines the Basic and Advanced tags and organize APIs using the two tags. The x-bookmark-id property specifies the URL fragment for the tag. { \"swagger\": \"2.0\", \"info\": { \"title\": \"Contacts\", \"version\": \"1.6\" }, \"host\": \"microsoft.com\", \"basePath\": \"/docfx\", \"schemes\": [ \"https\" ], \"tags\": [ { \"name\": \"Basic\", \"x-bookmark-id\": \"BasicBookmark\", \"description\": \"Basic description\" }, { \"name\": \"Advanced\", \"description\": \"Advanced description\" } ], \"paths\": { \"/contacts\": { \"get\": { \"operationId\": \"get_contacts\", \"tags\": [ \"Basic\", \"Advanced\" ] }, \"set\": { \"operationId\": \"set_contacts\", \"tags\": [ \"Advanced\" ] }, \"delete\": { \"operationId\": \"delete_contacts\" } } } } The above example produces the following layout: Basic ├─ get_contacts Advanced ├─ get_contacts ├─ set_contacts Other APIs ├─ delete_contacts"
  },
  "docs/table-of-contents.html": {
    "href": "docs/table-of-contents.html",
    "title": "Table of Contents | docfx",
    "keywords": "Table of Contents A table of contents (TOC) defines the structure of a set of documents. YAML TOC To add a TOC, create a file named toc.yml . Here's the structure for a simple YAML TOC: items: - name: Tutorial items: - name: Introduction href: tutorial.md - name: Step 1 href: step-1.md - name: Step 2 href: step-2.md - name: Step 3 href: step-3.md The YAML document is a tree of TOC nodes, each of which has these properties: name : The display name for the TOC node. href : The path the TOC node leads to. Optional because a node can exist just to parent other nodes. items : If a node has children, they're listed in the items array. Navigation Bar The toc.yml file in the docfx.json folder will be used to fill the content of the navigation bar at the top of the page. Nested TOCs To nest a TOC within another TOC, set the href property to point to the toc.yml file that you want to nest. You can also use this structure as a way to reuse a TOC structure in one or more TOC files. Consider the following two toc.yml files: toc.yml : items: - name: Overview href: overview.md - name: Reference href: api/toc.yml api/toc.yml : items: - name: System.String href: system.string.yml - name: System.Float href: system.float.yml This structure renders as follows: Overview Reference ├─ System.String ├─ System.Float"
  },
  "docs/template.html": {
    "href": "docs/template.html",
    "title": "Template | docfx",
    "keywords": "Template Template defines the appearance of the website. Docfx ships a default website template with the same look and feel as this site. Additional templates are available at the Template Gallary . Create a Custom Template To build your own template, create a new folder and add it to templates config in docfx.json : { \"build\": { \"templates\": [ \"default\", \"my-template\" // <-- Path to custom template ] } } Add your custom CSS file to styles/main.css and JavaScript file to styles/main.js . Docfx loads these 2 files and use them to style the website. This is an example stylesheet that adjust the font size of article headers: /* file: styles/main.css */ article h1 { font-size: 40px; } Custom HTML Templates In addition to CSS and JavaScript, you can customize how docfx generates HTML using Mustache Templates . Create a partials/footer.tmpl.partial file to replace the footer. This example update the footer to show a GitHub Follow button. <footer> <a class=\"github-button\" href=\"{{source.remote.repo}}\" data-size=\"large\" aria-label=\"Follow\">Follow</a> <script async defer src=\"https://buttons.github.io/buttons.js\"></script> </footer> The list of customizable HTML components are: partials/logo.tmpl.partial : The logo in the header. partials/footer.tmpl.partial : The footer at the bottom of the page. partials/affix.tmpl.partial : The right rail. partials/breadcrumb.tmpl.partial : The breadcrumb bar. Template Variables Metadata and other properties are available to the template engine. To see the template JSON input model, build with --exportRawModel command line option. Here are some predefined variables available to the template: Name Description _rel The relative path of the root output folder from current output file. For example, if the output file is a/b/c.html from root output folder, then the value is ../../ . _path The path of current output file starting from root output folder. _navPath The relative path of the root TOC file from root output folder, if exists. The root TOC file stands for the TOC file in root output folder. For example, if the output file is html file, the value is toc.html . _navRel The relative path from current output file to the root TOC file, if exists. For example, if the root TOC file is toc.html from root output folder, the value is empty. _navKey The original file path of the root TOC file starting with ~/ . ~/ stands for the folder where docfx.json is in, for example, ~/toc.md . _tocPath The relative path of the TOC file that current output file belongs to from root output folder, if current output file is in that TOC file. If current output file is not defined in any TOC file, the nearest TOC file is picked. _tocRel The relative path from current output file to its TOC file. For example, if the TOC file is a/toc.html from root output folder, the value is ../ . _tocKey The original file path of the TOC file starting with ~/ . ~/ stands for the folder where docfx.json is in, for example, ~/a/toc.yml ."
  },
  "extensions/packages.html": {
    "href": "extensions/packages.html",
    "title": "Packages |",
    "keywords": ""
  },
  "extensions/templates.html": {
    "href": "extensions/templates.html",
    "title": "Templates |",
    "keywords": ""
  },
  "extensions/tools.html": {
    "href": "extensions/tools.html",
    "title": "Tools |",
    "keywords": ""
  },
  "index.html": {
    "href": "index.html",
    "title": "Quick Start | docfx",
    "keywords": "Quick Start Build your technical documentation site with docfx. Converts .NET assembly, XML code comment, REST API Swagger files and markdown into rendered HTML pages, JSON model or PDF files. Create a New Website In this section we will build a simple documentation site on your local machine. Prerequisites Familiarity with the command line Install .NET SDK 6.0 or higher Make sure you have .NET SDK installed, then open a terminal and enter the following command to install the latest docfx: dotnet tool update -g docfx To create a new docset, run: docfx init --quiet This command creates a new docset under the docfx_project directory. To build the docset, run: docfx docfx_project/docfx.json --serve Now you can preview the website on http://localhost:8080 . To preview your local changes, save changes then run this command in a new terminal to rebuild the website: docfx docfx_project/docfx.json Publish to GitHub Pages Docfx produces static HTML files under the _site folder ready for publishing to any static site hosting servers. To publish to GitHub Pages: Enable GitHub Pages . Upload _site folder to GitHub Pages using GitHub actions. This example uses peaceiris/actions-gh-pages to publish to the gh-pages branch: # Your GitHub workflow file under .github/workflows/ jobs: publish-docs: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: actions/setup-dotnet@v3 with: dotnet-version: 6.x - run: dotnet install -g docfx - run: docfx docs/docfx.json - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: docs/_site Use the NuGet Library You can also use docfx as a NuGet library: <PackageReference Include=\"Microsoft.DocAsCode.App\" Version=\"2.60.0\" /> Then build a docset using: await Microsoft.DocAsCode.Docset.Build(\"docfx.json\"); See API References for additional APIs. Next Steps Write Articles Organize Contents Configure Website Add .NET API Docs"
  },
  "README.html": {
    "href": "README.html",
    "title": "| docfx",
    "keywords": "Documentation project uses docfx.console nuget package to generate documentation for docfx project, along with conceputal files, with docfx.json to provide configuration for docfx ."
  },
  "spec/docfx_build_manifest_file.html": {
    "href": "spec/docfx_build_manifest_file.html",
    "title": "Data structure for manifest file generated by docfx build | docfx",
    "keywords": "Data structure for manifest file generated by docfx build After docfx build , docfx generates a manifest file in JSON format in the root output folder, listing some basic information about the set of files that docfx build handles. Before DocFX version 1.7, the manifest file is an Array of items. Then DocFX realizes that there are also global properties manifest file consumers care about, for example, the list of TOC files that DocFX processed. However, it is hard to add properties to an Array model. So since version 1.8, DocFX introduces a new Object model for the manifest file. For backward compatibility, in version 1.8, DocFX generates both Array model to-be-obsoleted and the new Object model. In version 1.9, manifest file in Array model is removed . In version 2.24, version is obsolete and group is used instead. Below table shows the difference between manifest file in Array model and manifest file in Object model. ---- File Name Data Model Old Array Model .manifest Array model New Object Model manifest.json Object model The obsoleted Array model Array model contains a list of Manifest Item s. The new Object model Current supported properties for the Object model is listed as below: Property Type Description source_base_path string the directory path which contains docfx.json files List< ManifestItem > contains the information of all the output files. ( doesn't include templates and themes ) incremental_info List< IncrementalInfo > contains incremental infomation. groups List< ManifestGroupInfo > contains information of groups. sitemap object contains options for generating site map for post processor use xrefmap object deprecated, use xrefmap in groups version_info List<VersionInfo> deprecated, use groups homepages List<string> deprecated ManifestItem Property Type Description type string The documentType is generated by plugins or specified to each file using Yaml Header . Currently by default DocFX generates following document type s: ManagedReference , Conceptual , RestApi , Resource , Toc . source_relative_path string the input file path, relative to docfx.json output Dictionary<string, OutputFileInfo > For each output file, the key is the extension of the transformed file, the extension is determined by the template it applies to. is_incremental bool indicates whether this file is incremtal or rebuilt this time version string deprecated, use group group string the group the current item belongs to log_codes List the codes logged when building the current item OutputFileInfo Property Type Description relative_path string the logical output file path relative to output root. If it doesn't exist physically, it can be found through link_to_path link_to_path string the physical output file path hash string tha hash of the output file content IncrementalInfo Property Type Description status IncrementalStatus current build's overall incremental information processors Dictionary<string, IncrementalStatus > incremental information of each processor. Key is the name of the processor. IncrementalStatus Property Type Description can_incremental bool indicates whenther current build supports incremental build details string detailed explanation of the build status incrementalPhase string the phase of the status, can be Build or PostProcessing ManifestGroupInfo Property Type Description name string group name ( default group hasn't this property ) dest string group output folder, relative to the root output folder ( default group hasn't this property ) xrefmap string group xrefmap's path in output folder"
  },
  "spec/docfx_design_spec.html": {
    "href": "spec/docfx_design_spec.html",
    "title": "docfx Design Spec | docfx",
    "keywords": "docfx Design Spec 0. Terms Term Description DFM DocFX Flavored Markdown API The API generated from source code Overwrite Files The files with YAML header used to override YAML files when uid matches. 1. Scenarios docfx should support the following scenarios: Source Code => Website Conceptual => Website YAML files => Website 2. Architecture 3. Feature List Support for DocFX Flavored Markdown Ability to parse TOC.json/TOC.yml/TOC.md Custom template naming: {type}.{extension}.tmpl under folder {templateName} 4. Open Issues Should we support other conceptual file format, for example, RST? ==> How to parse? How do you know which link to replace to html, and which not? ==>"
  },
  "spec/docfx_document_schema.html": {
    "href": "spec/docfx_document_schema.html",
    "title": "DocFX Document Schema v1.0 Specification | docfx",
    "keywords": "DocFX Document Schema v1.0 Specification 1. Introduction DocFX supports different document processors to handle different kinds of input. For now, if the data model changes a bit, a new document processor is needed, even most of the work in processors are the same. DocFX Document Schema (abbreviated to THIS schema below) is introduced to address this problem. This schema is a JSON media type for defining the structure of a DocFX document. This schema is intended to annotate , validate and interpret the document data. 2. Conventions and Terminology The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . 3. Overview DocFX Document Schema is in JSON format. It borrows most syntax from JSON Schema , while it also introduces some other syntax to manipulate the data. 3.1 Annotation THIS schema is a JSON based format for the structure of a DocFX document. 3.2 Validation JSON schema validation already defines many keywords. This schema starts from supporting limited keyword like type , properties . 3.3 Interpretation Besides annotate and validate the input document model, THIS schema also defines multiple interpretations for each property of the document model. For example, a property named summary contains value in Markdown format, THIS schema can define a markup interpretation for the summary property, so that the property can be marked using DFM syntax. 4. General Considerations THIS schema leverages JSON schema definition, that is to say, keywords defined in JSON schema keeps its meaning in THIS schema when it is supported by THIS schema . 5. Detailed Specification Format The files describing DocFX document model in accordance with the DocFX document schema specification are represented as JSON objects and conform to the JSON standards. YAML, being a superset of JSON, can be used as well to represent a DocFX document schema specification file. All field names in the specification are case sensitive . This schema exposes two types of fields. Fixed fields, which have a declared name, and Patterned fields, which declare a regex pattern for the field name. Patterned fields can have multiple occurrences as long as each has a unique name. By convention, the schema file is suffixed with .schema.json . Data Types Primitive data types in THIS schema are based on JSON schema Draft 6 4.2 Instance Schema For a given field, * as the starting character in Description cell stands for required . Schema Object This is the root document object for THIS schema . Fixed Field Field Name Type Description $schema string * The version of the schema specification, for example, https://dotnet.github.io/docfx/schemas/v1.0/schema.json# . version string * The version of current schema object. id string It is best practice to include an id property as an unique identifier for each schema. title string The title of current schema, LandingPage , for example. In DocFX, this value can be used to determine what kind of documents apply to this schema, If not specified, file name before schema.json of this schema is used. Note that . is not allowed. description string A short description of current schema. type string * The type of the root document model MUST be object . properties Property Definitions Object An object to hold the schema of all the properties. metadata string In json-pointer format as defined in http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.3.9 . The format for JSON pointer is defined by https://tools.ietf.org/html/rfc6901 , referencing to the metadata object. Metadata object is the object to define the metadata for current document, and can be also set through globalMetadata or fileMetadata in DocFX. The default value for metadata is empty which stands for the root object. Patterned Field Field Name Type Description ^x- Any Allows extensions to THIS schema . The field name MUST begin with x-, for example, x-internal-id. The value can be null, a primitive, an array or an object. Property Definitions Object It is an object where each key is the name of a property and each value is a schema to describe that property. Patterned Field Field Name Type Description {name} Property Object The schema object for the {name} property Property Object An object to describe the schema of the value of the property. Fixed Field Field Name Type Description title string The title of the property. description string A lengthy explanation about the purpose of the data described by the schema. default what type defined The default value for current field. type string The type of the root document model. Refer to type keyword for detailed description. properties Property Definitions Object An object to hold the schema of all the properties if type for the model is object . Omitting this keyword has the same behavior as an empty object. items Property Object An object to hold the schema of the items if type for the model is array . Omitting this keyword has the same behavior as an empty schema. reference string Defines whether current property is a reference to the actual value of the property. Refer to reference for detailed explanation. contentType string Defines the content type of the property. Refer to contentType for detailed explanation. tags array Defines the tags of the property. Refer to tags for detailed explanation. mergeType string Defines how to merge the property. Omitting this keyword has the same behavior as merge . Refer to mergeType for detailed explanation. xrefProperties array Defines the properties of current object when it is cross referenced by others. Each item is the name of the property in the instance. Refer to xrefProperties for detailed description of how to leverage this property. Patterned Field Field Name Type Description ^x- Any Allows extensions to THIS schema . The field name MUST begin with x-, for example, x-internal-id. The value can be null, a primitive, an array or an object. 6. Keywords in detail 6.1 type Same as in JSON schema: http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.25 The value of this keyword MUST be either a string or an array. If it is an array, elements of the array MUST be strings and MUST be unique. String values MUST be one of the six primitive types (\"null\", \"boolean\", \"object\", \"array\", \"number\", or \"string\"), or \"integer\" which matches any number with a zero fractional part. An instance validates if and only if the instance is in any of the sets listed for this keyword. 6.2 reference It defines whether current property is a reference to the actual value of the property. The values MUST be one of the following: Value Description none It means the property is not a reference. file It means current property stands for a file path that contains content to be included. 6.3 contentType It defines how applications interpret the property. If not defined, the behavior is similar to default value. The values MUST be one of the following: Value Description default It means that no interpretion will be done to the property. uid type MUST be string . With this value, the property name MUST be uid . It means the property defines a unique identifier inside current document model. href type MUST be string . It means the property defines a file link inside current document model. Application CAN help to validate if the linked file exists, and update the file link if the linked file changes its output path. xref type MUST be string . It means the property defines a UID link inside current document model. Application CAN help to validate if the linked UID exists, and resolve the UID link to the corresponding file output link. file type MUST be string . It means the property defines a file path inside current document model. Application CAN help to validate if the linked file exists, and resolve the path to the corresponding file output path. The difference between file and href is that href is always URL encoded while file is not. markdown type MUST be string . It means the property is in DocFX flavored Markdown syntax. Application CAN help to transform it into HTML format. 6.4 tags The value of this keyword MUST be an array , elements of the array MUST be strings and MUST be unique. It provides hints for applications to decide how to interpret the property, for example, localizable tag can help Localization team to interpret the property as localizable . 6.5 mergeType The value of this keyword MUST be a string. It specifies how to merge two values of the given property. One use scenario is how DocFX uses the overwrite files to overwrite the existing values. In the below table, we use source and target to stands for the two values for merging. The value MUST be one of the following: Value Description key If key for source equals to the one for target , these two values are ready to merge. merge The default behavior. For array , items in the list are merged by key for the item. For string or any value type, target replaces source . For object , merge each property along with its own merge value. replace target replaces source . ignore source is not allowed to be merged. 6.6 xrefProperties The value of this keyword MUST be an array of string . Each string value is the property name of current object that will be exported to be Cross Referenced by others. To leverage this feature, a new xref syntax with template attribute is support: <xref uid=\"{uid}\" template=\"{path_of_partial_template}\" /> For the parital template, the input model is the object containing properties xrefProperties defines. For example, in the sample schema defined by 7. Samples , \"xrefProperties\": [ \"title\", \"description\" ], , title and description are xrefProperties for uid webapp . A partial template to render this xref, for example, named partials/overview.tmpl , looks like: {{title}}: {{{description}}} When someone references this uid using <xref uid=\"webapp\" template=\"partials/overview.tmpl\" , docfx expand this xref into the following html: Web Apps Documentation: <p>This is description</p> In this way, users can not only cross reference others to get the target url, but also cross reference other properties as they like. A common usage of this is the Namespace page in ManagedReference. The Namespace page shows a table of its Classes with the summary of the Class , with the help of xrefProperties , the source of truth summary is always from Class . For the Namespace page, it can, for example: Define a class.tr.tmpl template: <tr><td>{{name}}</td><td>{{{summary}}}</td></tr> The namespace namespace.tmpl template, use xref to render its children classes: {{#children}} <xref uid=\"{{uid}}\" template=\"class.tr.tmpl\" /> {{/children}} 7. Samples Here's an sample of the schema. Assume we have the following YAML file: ### YamlMime:LandingPage title: Web Apps Documentation description: This is description uid: webapp metadata: title: Azure Web Apps Documentation - Tutorials, API Reference meta.description: Learn how to use App Service Web Apps to build and host websites and web applications. services: app-service author: apexprodleads manager: carolz ms.service: app-service ms.tgt_pltfrm: na ms.devlang: na ms.topic: landing-page ms.date: 01/23/2017 ms.author: carolz sections: - title: 5-Minute Quickstarts children: - text: .NET href: app-service-web-get-started-dotnet.md - text: Node.js href: app-service-web-get-started-nodejs.md - text: PHP href: app-service-web-get-started-php.md - text: Java href: app-service-web-get-started-java.md - text: Python href: app-service-web-get-started-python.md - text: HTML href: app-service-web-get-started-html.md - title: Step-by-Step Tutorials children: - content: \"Create an application using [.NET with Azure SQL DB](app-service-web-tutorial-dotnet-sqldatabase.md) or [Node.js with MongoDB](app-service-web-tutorial-nodejs-mongodb-app.md)\" - content: \"[Map an existing custom domain to your application](app-service-web-tutorial-custom-domain.md)\" - content: \"[Bind an existing SSL certificate to your application](app-service-web-tutorial-custom-SSL.md)\" In this sample, we want to use the JSON schema to describe the overall model structure. Further more, the href is a file link. It need to be resolved from the relative path to the final href. The content property need to be marked up as a Markdown string. The metadata need to be tagged for further custom operations. We want to use section 's title as the key for overwrite section array. Here's the schema to describe these operations: { \"$schema\": \"https://dotnet.github.io/docfx/schemas/v1.0/schema.json#\", \"version\": \"1.0.0\", \"id\": \"https://github.com/dotnet/docfx/schemas/landingpage.schema.json\", \"title\": \"LandingPage\", \"description\": \"The schema for landing page\", \"type\": \"object\", \"xrefProperties\": [ \"title\", \"description\" ], \"properties\": { \"metadata\": { \"type\": \"object\", \"tags\": [ \"metadata\" ] }, \"uid\": { \"type\": \"string\", \"contentType\": \"uid\" }, \"sections\": { \"type\": \"array\", \"items\": { \"type\": \"object\", \"properties\": { \"children\": { \"type\": \"array\", \"items\": { \"type\": \"object\", \"properties\": { \"href\": { \"type\": \"string\", \"contentType\": \"href\" }, \"text\": { \"type\": \"string\", \"tags\": [ \"localizable\" ] }, \"content\": { \"type\": \"string\", \"contentType\": \"markdown\" } } } }, \"title\": { \"type\": \"string\", \"mergeType\": \"key\" } } } }, \"title\": { \"type\": \"string\" } } } 8. Q & A DocFX fills _global metadata into the processed data model, should the schema reflect this behavior? Decision: NOT include, this schema is for input model , use another schema for output model. Is it necessary to prefix d- to every field that DocFX introduces in? If keep d- Pros: d- makes it straightforward that these keywords are introduced by DocFX Keywords DocFX introduces in will never duplicate with the one preserved by JSON schema Cons: d- prefix provides a hint that these keywords are not first class keywords Little chance that keywords DocFX defines duplicate with what JSON schema defines, after all, JSON schema defines a finite set of reserved keywords. For example Swagger spec is also based on JSON schema and the fields it introduces in has no prefix. Decision: Remove d- prefix."
  },
  "spec/docfx_flavored_markdown.html": {
    "href": "spec/docfx_flavored_markdown.html",
    "title": "DocFX Flavored Markdown | docfx",
    "keywords": "DocFX Flavored Markdown DocFX supports DocFX Flavored Markdown , aka DFM. It supports all GitHub Flavored Markdown syntax and compatible with CommonMark. Also, DFM adds new syntax to support additional functionalities, including cross reference and file inclusion. Note The default markdown engine generated by docfx init has been switched to markdig engine, which is built on the top of markdig . Previous markdown engine dfm and dfm-latest will be kept for compatibiilty. Yaml Header Yaml header in DFM is considered as the metadata for the Markdown file. It will transform to yamlheader tag when processed. Yaml header MUST be the first thing in the file and MUST take the form of valid YAML set between triple-dashed lines. Here is a basic example: --- uid: A.md title: A --- Cross Reference Cross reference allows you to link to another topic by using its unique identifier (called UID) instead of using its file path. For conceptual Markdown files UID can be defined by adding a uid metadata in YAML header: --- uid: uid_of_the_file --- This is a conceptual topic with `uid` specified. For reference topics, UIDs are auto generated from source code and can be found in generated YAML files. You can use one of the following syntax to cross reference a topic with UID defined: Markdown link: [link_text](xref:uid_of_the_topic) Auto link: <xref:uid_of_the_topic> Shorthand form: @\"uid_of_the_topic\" All will render to: <a href=\"url_of_the_topic\">link_text</a> If link_text is not specified, DocFX will extract the title from the target topic and use it as the link text. Do not use the @uid link in brackets (like this: (@uid) ). DocFX cannot parse this link. The @uid link should be separated with white spaces. If you need to add a link in brackets, use [](xref:uid) . Note Hashtag in xref is always treated as separator between file name and anchor name. That means if you have # in UID, it has to be encoded to %23 . Actually xref format follows URI standard so all reserved characters should be encoded. For more information, see cross reference . File Inclusion DFM adds syntax to include other file parts into current file, the included file will also be considered as in DFM syntax. There are two types of file inclusion: Inline and block, as similar to inline code span and block code. Note YAML header is NOT supported when the file is an inclusion. Inline Inline file inclusion is in the following syntax, in which <title> stands for the title of the included file, and <filepath> stands for the file path of the included file. The file path can be either absolute or relative. <filepath> can be wrapped by ' or \" . Note For inline file inclusion, the file included will be considered as containing only inline tags, for example, ### header inside the file will not transfer since <h3> is a block tag, while [a](b) will transform to <a href='b'>a</a> since <a> is an inline tag. Also, ending white spaces will be trimmed , considering ending white spaces in inline inclusion in most cases are typos. ...Other inline contents... [!include[<title>](<filepath>)] Block Block file inclusion must be in a single line and with no prefix characters before the start [ . Content inside the included file will transform using DFM syntax. [!include[<title>](<filepath>)] Section definition User may need to define section. Mostly used for code table. Give an example below. > [!div class=\"tabbedCodeSnippets\" data-resources=\"OutlookServices.Calendar\"] > ```cs > <cs code text> > ``` > ```javascript > <js code text> > ``` The above blockquote Markdown text will transform to section html as in the following: <div class=\"tabbedCodeSnippets\" data-resources=\"OutlookServices.Calendar\"> <pre><code>cs code text</code></pre> <pre><code>js code text</code></pre> </div> Code Snippet Allows you to insert code with code language specified. The content of specified code path will expand. [!code-<language>[<name>](<codepath><queryoption><queryoptionvalue> \"<title>\")] <language> can be made up of any number of character and '-'. However, the recommended value should follow Highlight.js language names and aliases . <codepath> is the path relative to the file containing this markdown content in file system, which indicates the code snippet file that you want to expand. <queryoption> and <queryoptionvalue> are used together to retrieve part of the code snippet file in the line range or tag name way. We have 2 query string options to represent these two ways: query string using # query string using ? 1. line range #L{startlinenumber}-L{endlinenumber} ?start={startlinenumber}&end={endlinenumber} 2. tagname #{tagname} ?name={tagname} 3. multiple region range Unsupported ?range={rangequerystring} 4. highlight lines Unsupported ?highlight={rangequerystring} 5. dedent Unsupported ?dedent={dedentlength} In ? query string, the whole file will be included if none of the first three option is specified. If dedent isn't specified, the maximum common indent will be trimmed automatically. <title> can be omitted as it doesn't affect the DocFX markup result, but it can beautify the result of other Markdown engine, like GitHub Preview. Code Snippet Sample [!code-csharp[Main](Program.cs)] [!code[Main](Program.cs#L12-L16 \"This is source file\")] [!code-vb[Main](../Application/Program.vb#testsnippet \"This is source file\")] [!code[Main](index.xml?start=5&end=9)] [!code-javascript[Main](../jquery.js?name=testsnippet)] [!code[Main](index.xml?range=2,5-7,9-) \"This includes the lines 2, 5, 6, 7 and lines 9 to the last line\"] [!code[Main](index.xml?highlight=2,5-7,9-) \"This includes the whole file with lines 2,5-7,9- highlighted\"] Tag Name Representation in Code Snippet Source File DFM currently supports the following <language> values to be able to retrieve by tag name: C family Start with: // <{name}> End with: // </{name}> Languages: actionscript, arduino, assembly (alias: nasm), c (alias: cpp, c++, objective-c, obj-c, objc, objectivec), csharp (alias: cs), cshtml, cuda, d (alias: dlang), fsharp (alias: fs), go (alias: golang), java, javascript (alias: js, node), pascal, php, processing, rust, scala, smalltalk, swift, typescript (alias: ts) File extensions: .as, .asm, .ino, .c, .cc, .cpp, .cs, .cshtml .cu, .cuh, .d, .fs, .fsi, .fsx, .go, .h, .hpp, .java, .js, .pas, .php, .pde, .rs, .scala, .st, .swift, .ts Basic family Start with: ' <{name}> End with: ' </{name}> Languages: vb, vbhtml, vbnet, vbscript File extensions: .bas, .vb, .vba, .vbhtml, .vbs Markup language family Start with: <!-- <{name}> --> End with: <!-- </{name}> --> Languages: cshtml, html, vbhtml, wsdl, xml, xsl, xslt, xsd, xaml File extensions: .asp, .aspx, .csdl, .cshtml, .edmx, .jsp, .vbhtml, .wsdl, .xaml, .xml, .xsd, .xsl, .xslt, .html Sql family Start with: -- <{name}> End with: -- </{name}> Languages: sql File extensions: .sql Script family Start with: # <{name}> End with: # </{name}> Languages: perl, powershell (alias: posh), python, r, ruby (alias: ru), shell (alias: sh, bash) File extensions: .bash, .pl, .ps1, .py, .r, .ru, .ruby, .sh Special language batchfile Start with: rem <{name}> End with: rem </{name}> Languages: batchfile File extensions: .bat .cmd csharp Start with: #region {name} End with: #endregion Languages: csharp (alias: cs) File extensions: .cs .cshtml erlang Start with: % <{name}> End with: % </{name}> Languages: erlang File extensions: .erl haskell Start with: -- <{name}> End with: -- </{name}> Languages: haskell File extensions: .hs matlab Start with: % <{name}> End with: % </{name}> Languages: matlab File extensions: .matlab lisp Start with: ; <{name}> End with: ; </{name}> Languages: lisp File extensions: .lisp, .lsp lua Start with: -- <{name}> End with: -- </{name}> Languages: lua File extensions: .lua vb Start with: #Region {name} End with: #End Region Languages: vb (alias: vbnet) File extensions: .vb .vbhtml Note If dev-lang is not specified, file extension will be used to determine the language. Code Snippet for Jupyter Notebooks Allows you to insert code from a code cell of a Jupyter Notebook. The source content in the specified code cell will expand. Steps to use this: In your Jupyter Notebook, add metadata to the code cell you will reference: \"metadata\": { \"name\": \"{tagname}\" } In your .md file, use name to identify the cell. [!notebook-<language>[](<codepath>?name={tagname})]] Code Snippet for Jupyter Notebooks Sample For this Jupyter Notebook cell: { \"cells\": [ { \"cell_type\": \"code\", \"execution_count\": null, \"metadata\": { \"name\": \"import\" }, \"outputs\": [], \"source\": [ \"import azureml.core\\n\", \"print(azureml.core.VERSION)\" ] }, Use the markup: [!notebook-python[](<codepath>?name=\"import\")]] to display the lines of code in the source part of the cell: import azureml.core print(azureml.core.VERSION) Note (Warning/Tip/Important) Using specific syntax inside block quote to indicate the following content is Note. > [!NOTE] > <note content> > [!WARNING] > <warning content> The above content will be transformed to the following html: <div class=\"NOTE\"> <h5>NOTE</h5> <p>note content</p> </div> <div class=\"WARNING\"> <h5>WARNING</h5> <p>WARNING content</p> </div> Here are all the supported note types with the styling of the default theme applied: Note This is a note which needs your attention, but it's not super important. Tip This is a note which needs your attention, but it's not super important. Warning This is a warning containing some important message. Important This is a warning containing some important message. Caution This is a warning containing some important message. Tabbed content Syntax Start a tab by a special markdown title (any level). Title content should be a markdown link. Link target is #tab/{tabid} or #tab/{tabid}/{condition} Continue by any other content. End by a markdown hr. Example Tab group 1: # [Tab Text 1](#tab/tabid-1) Tab content-1-1. # [Tab Text 2](#tab/tabid-2) Tab content-2-1. *** Tab group 2: # [Tab Text A](#tab/tabid-a) Tab content-a-1. # [Tab Text B](#tab/tabid-b) Tab content-b-1. *** Tab group 3: # [Tab Text 1](#tab/tabid-1) Tab content-1-2. # [Tab Text 2](#tab/tabid-2) Tab content-2-2. *** Tab group 4: # [Tab Text A](#tab/tabid-a) Tab content-a-2. # [Tab Text B](#tab/tabid-b) Tab content-b-2. *** The result will be: Tab group 1: Tab Text 1 Tab Text 2 Tab content-1-1. Tab content-2-1. Tab group 2: Tab Text A Tab Text B Tab content-a-1. Tab content-b-1. Tab group 3: Tab Text 1 Tab Text 2 Tab content-1-2. Tab content-2-2. Tab group 4: Tab Text A Tab Text B Tab content-a-2. Tab content-b-2. Behavior Tab groups with a same set of id are linkable in one page. In example, tab group 1, 3 have same id set: tabid-1 , tabid-2 , tab group 2, 4 have same id set: tabid-a , tabid-b . So tab group 1, 3 are linked, tab group 2, 4 are linked. When tab tabid-1 in tab group 1 is clicked, tab tabid-1 in tab group 3 will be selected in same time. But tab group 2, 4 do not have any changed. Condition Condition is the tab id of other table groups. e.g.: Tab Group 1: # [**Tab Text 1**](#tab/tabid-1) Tab content-1. # [**Tab Text 2**](#tab/tabid-2) Tab content-2. *** Tab Group 2: # [Tab Text A](#tab/tabid-a/tabid-1) Tab content-a for 1. # [Tab Text A](#tab/tabid-a/tabid-2) Tab content-a for 2. # [Tab Text B](#tab/tabid-b/tabid-1) Tab content-b for 1. # [Tab Text B](#tab/tabid-b/tabid-2) Tab content-b for 2. *** Result: Tab Group 1: Tab Text 1 Tab Text 2 Tab content-1. Tab content-2. Tab Group 2: Tab Text A Tab Text A Tab Text B Tab Text B Tab content-a for 1. Tab content-a for 2. Tab content-b for 1. Tab content-b for 2. When select tabid-1 in tab group 1, you can get content-a or content-b for 1 in group 2. When select tabid-2 in tab group 1, you can get content-a or content-b for 2 in group 2. Video Allows you to add videos to your topics. Syntax: > [!Video embed_link] Note You must provide the embed uri of the video you wish to add to your topic. Example: > [!Video https://www.youtube.com/embed/TAaG0nUUy6A] Result: Differences introduced by DFM syntax Warning DFM introduces more syntax to support more functionalities. When GFM does not support them, preview the Markdown file inside GFM Preview can lead to different results. YAML header In GFM, YAML header must start at the very beginning of the Markdown file. In DFM, YAML header contains more powerful meanings. Refer to Yaml Header for details. ...some text... --- a: b --- In GFM, it would be rendered as <hr>a: b<hr> . In DFM, it would be rendered as a YAML header. If you want to get <hr> in html in DFM, use: - - - *** * * * or change content to make it not in YAML format: --- a\\: b --- Text after block extension Some block extension in DFM cannot be recognized in GFM. In GFM, it would be treated as a part of paragraph. Then, following content would be treated as a part of paragraph. For example: > [!NOTE] > This is code. In GFM, it will be rendered as a paragraph with content [!NOTE] This is code. in blockquote. In DFM, it will be rendered as a code in note."
  },
  "spec/docfx_incremental.html": {
    "href": "spec/docfx_incremental.html",
    "title": "Doc-as-code: DocFx.exe Incremental Build Specification | docfx",
    "keywords": "Doc-as-code: DocFx.exe Incremental Build Specification This documentation describes the implementation of incrementally extracting metadata from source. Currently we are using Roslyn to compile and analyse source code on the fly. When input sources are large, it may take minutes to load and process the files. To speed up the extraction, previous extracted details are saved to cache for further reference. There are two level caches in current implementation. First one is called Application Level cache, and the other one is Project level cache. Application level cache is saved in file %LocalAppData%/xdoc/cache . For Project level cache, a. If input sources are supported project files, e.g. .csproj or .vbproj files, Project level cache is located in file obj/xdoc/.cache under the same folder of the project file. b. If input sources are supported source code files, e.g. .cs or .vb files, Project level cache is located in file obj/xdoc/.cache under the same folder of the alphabetically first source code file. The cache file contains key-value pairs saved in JSON format. The key is the normalized input source code files, and the data structure for the value is as below: Property Description TriggeredUTCTime The UTC time when the action is triggered CompletedUTCTime The UTC time when the action is completed OutputFolder The output folder for the extracted result RelativeOutputFiles The paths of the extracted results related to the OutputFolder CheckSum The MD5 checksum calculated for all the extracted results Detailed Steps are described below: For each input solution/project/source files, get most latest LastModifiedTime . a. For solution, get LastModifiedTime for the solution file, and containing projects b. For project, get LastModifiedTime for the project file, project references, assembly references and containing documents. c. For source files, get LastModifiedTime for the files Normalize project list, check if Application level cache for these project list exists. Compare TriggeredUTCTime with the LastModifiedTime fetched in #1, and check if checksum remains unchanged for output files. If is, copy result files to output folder. Otherwise, continue to #3. For each supported solution/project/source code files, Step 1 . Check if Project level cache exists. If not, go to Step 4 . Step 2 . Compare TriggeredUTCTime with the LastModifiedTime fetched in #1, and check if checksum remains unchanged for output files. If not, go to Step 3 . Step 3 . Generate YAML metadata for current project and save to Project level cache. Read YAML metadata for each project, and merge with others following rules below: Rule 1 . For namespace , if uid equals, append . Rule 2 . For other type, if uid equals, override . Save result, and update * Application level cache."
  },
  "spec/metadata_dotnet_spec.html": {
    "href": "spec/metadata_dotnet_spec.html",
    "title": "DocFx: Metadata Format for .NET Languages | docfx",
    "keywords": "DocFx: Metadata Format for .NET Languages 0. Introduction 0.1 Goal and Non-goals 0.2 Terminology 1. Items The following .NET elements are defined as items in metadata: Namespaces Types, including class, struct, interface, enum, delegate Type members, including field, property, method, event Other elements such as parameters and generic parameters are not standalone items , they're part of other items . 2. Identifiers 2.1 Unique Identifiers For any item in .NET languages, its UID is defined by concatenating its parent 's UID and its own ID with a dot. The ID for each kind of item is defined in following sections. The basic principle here is to make ID format close to source code and easy for human reading. UID is similar to the document comment id, which is started with type prefix, for example, T: , or M: , but UID do not. There MUST NOT be any whitespace between method name, parentheses, parameters, and commas. 2.2 Spec Identifiers Spec identifier is another form of UID . It can spec a generic type with type arguments (for example, for parameters, return types or inheritances) and these UID s are unique in one yaml file. It is a simple modified Unique Identifiers, when it contains generic type arguments, it will use {Name} instead `N . For type parameter, it will be {Name} . And it also supports array and pointer. Example 2.2 Spec Identifier C#: namespace Foo { public class Bar { public unsafe List<String> FooBar<TArg>(int[] arg1, byte* arg2, TArg arg3, List<TArg[]> arg4) { return null; } } } YAML: references: - uid: System.Collections.Generic.List{System.String} - uid: System.Int32[] - uid: System.Byte* - uid: {TArg} - uid: System.Collections.Generic.List{{TArg}[]} 3. Namespaces For all namespaces, they are flat, e.i. namespaces do not have the parent namespace. So for any namespace, ID is always same with its UID . Example 3 Namespace C#: namespace System.IO { } YAML: uid: System.IO id: System.IO name: System.IO fullName: System.IO The children of namespace are all the visible types in the namespace. 4. Types Types include classes, structs, interfaces, enums, and delegates. They have following properties: summary, remarks, syntax, namespace, assemblies, inheritance. The parents of types are namespaces. The children of types are members. ID ID for a type is also its name . Example 4 Type C#: namespace System { public class String {} public struct Boolean {} public interface IComparable {} public enum ConsoleColor {} public delegate void Action(); } YAML: - uid: System.String id: String name.csharp: String fullName.csharp: System.String - uid: System.Boolean id: Boolean name.csharp: Boolean fullName.csharp: System.String - uid: System.IComparable id: IComparable name.csharp: IComparable fullName.csharp: System.IComparable - uid: System.ConsoleColor id: ConsoleColor name.csharp: ConsoleColor fullName.csharp: System.ConsoleColor - uid: System.Action id: Action name.csharp: Action fullName.csharp: System.Action 4.1 ID for Nested Types For nested types, ID is defined by concatenating the ID of all its containing types and the ID of itself, separated by a dot. The parent type of a nested type is its containing namespace, rather than its containing type. Example 4.1 Nested type C#: namespace System { public class Environment { public enum SpecialFolder {} } } YAML: uid: System.Environment.SpecialFolder id: Environment.SpecialFolder name.csharp: Environment.SpecialFolder fullName.csharp: System.Environment.SpecialFolder 4.2 Inheritance Only class contains inheritance, and the inheritance is a list of spec id. Example 4.2 Inheritance C#: namespace System.Collections.Generic { public class KeyedByTypeCollection<TItem> : KeyedCollection<Type, TItem> { } } YAML: uid : System.Collections.Generic.KeyedByTypeCollection`1 inheritance: - System.Collections.ObjectModel.KeyedCollection{System.Type,{TItem}} - System.Collections.ObjectModel.Collection{{TItem}} - System.Object 4.3 Syntax The syntax part for type contains declaration, and descriptions of type parameters for different languages. For delegates, it also contains descriptions of parameters and a return type. 5. Members Members include fields, properties, methods, and events. They have the following properties: summary, remarks, exceptions, and syntax. The parents of members are types. Members never have children, and all parameter types or return types are spec id. 5.1 Constructors The ID of a constructor is defined by #ctor , followed by the list of the UIDs of its parameter types: When a constructor does not have parameter, its ID MUST NOT end with parentheses. The syntax part for constructors contains a special language declaration, and descriptions of parameters. Example 5.1 Constructor C#: namespace System { public sealed class String { public String(); public String(char[] chars); } } YAML: - uid: System.String.#ctor id: #ctor name.csharp: String() fullName.csharp: System.String.String() - uid: System.String.#ctor(System.Char[]) id: #ctor(System.Char[]) name.csharp: String(Char[]) fullName.csharp: System.String.String(System.Char[]) 5.2 Methods The ID of a method is defined by its name, followed by the list of the UIDs of its parameter types: method_name(param1,param2,...) When a method does not have parameter, its ID MUST end with parentheses. The syntax part for method contains a special language declaration, and descriptions of type parameters for generic method, descriptions of parameters and return type. Example 5.2 Method C#: namespace System { public sealed class String { public String ToString(); public String ToString(IFormatProvider provider); } } YAML: - uid: System.String.ToString id: ToString name.csharp: ToString() fullName.csharp: System.String.ToString() - uid: System.String.ToString(System.IFormatProvider) id: ToString(System.IFormatProvider) name.csharp: ToString(IFormatProvider) fullName.csharp: System.String.ToString(System.IFormatProvider) 5.2.1 Explicit Interface Implementation The ID of an explicit interface implementation (EII) member MUST be prefixed by the UID of the interface it implements and replace . to # . Example 2.6 Explicit interface implementation (EII) C#: namespace System { using System.Collections; public sealed class String : IEnumerable { IEnumerator IEnumerable.GetEnumerator(); } } YAML: - uid: \"System.String.System#Collections#IEnumerable#GetEnumerator\" id: \"System#Collections#IEnumerable#GetEnumerator\" name.csharp: IEnumerable.GetEnumerator() fullName.csharp: System.String.System.Collections.IEnumerable.GetEnumerator() 5.4 Operator Overloads The IDs of operator overloads are same with the metadata name (for example, op_Equality ). The names of operator overloads are similar to MSDN, just remove op_ from the metadata name of the method. For instance, the name of the equals ( == ) operator is Equality . Type conversion operator can be considered a special operator whose name is the UID of the target type, with one parameter of the source type. For example, an operator that converts from string to int should be Explicit(System.String to System.Int32) . The syntax part for methods contains a special language declaration, descriptions of parameters and return type. Example 5.4 Operator overload namespace System { public struct Decimal { public static implicit operator Decimal(Char value); } public sealed class String { public static bool operator ==(String a, String b); } } YAML: - uid: System.Decimal.op_Implicit(System.Char)~System.Decimal id: op_Implicit(System.Char)~System.Decimal name.csharp: Implicit(Char to Decimal) fullName.csharp: System.Decimal.Implicit(System.Char to System.Decimal) - uid: System.String.op_Equality(System.String,System.String) id: op_Equality(System.String,System.String) name.csharp: Equality(String,String) fullName.csharp: System.String.Equality(System.String,System.String) Please check overloadable operators for all overloadable operators. 5.5 Field, Property or Event The ID of field, property or event is its name. The syntax part for field contains a special language declaration and descriptions of field type. For property, it contains a special language declaration, descriptions of parameters, and return type. For event, it contains a special language declaration and descriptions of event handler type. Example 5.5 Field, Property and Event C#: namespace System { public sealed class String { public static readonly String Empty; public int Length { get; } } public static class Console { public static event ConsoleCancelEventHandler CancelKeyPress; } } YAML: - uid: System.String.Empty id: Empty name.csharp: Empty fullName.csharp: System.String.Empty - uid: System.String.Length id: Length name.csharp: Length fullName.csharp: System.String.Length - uid: System.Console.CancelKeyPress id: CancelKeyPress name.csharp: CancelKeyPress fullName.csharp: System.Console.CancelKeyPress 5.6 Indexer Indexer operator's name is metadata name, by default, it is Item , with brackets and parameters. Example 5.6 Indexer namespace System.Collections { public interface IList { object this[int index] { get; set; } } } YAML: - uid: \"System.Collections.IList.Item[System.Int32]\" id: \"Item[System.Int32]\" name.csharp: Item[Int32] fullName.csharp: System.Collections.IList.Item[System.Int32] 6. Generics The ID of a generic type is its name with followed by `n , n and the count of generic type count, which is the same as the rule for document comment ID. For example, Dictionary`2 . The ID of a generic method uses postfix ``n , n is the count of in method parameters, for example, System.Tuple.Create``1(``0) . Example 2.7 Generic namespace System { public static class Tuple { public static Tuple<T1> Create<T1>(T1 item1); public static Tuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2); } } YAML: - uid: System.Tuple.Create``1(``0) id: Create``1(``0) name.csharp: Create<T1>(T1) fullName.csharp: System.Tuple.Create<T1>(T1) - uid: System.Tuple.Create``2(``0,``1) id: Create``2(``0,``1) name.csharp: Create<T1,T2>(T1,T2) fullName.csharp: System.Tuple.Create<T1,T2>(T1,T2) 7. Reference The reference contains the following members: name, fullName, summary, isExternal, href, and more. The UID in reference can be a Spec Id , then it contains one more member: spec. The spec in reference is very like a list of lightweight references, it describes how to compose the generic type in some special language. Example 7 spec for references YAML: references: - uid: System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{System.Int32}} name.csharp: Dictionary<String, List<Int32>> fullName.csharp: System.Collections.Generic.Dictionary<System.String, System.Collections.Generic.List<System.Int32>> spec.csharp: - uid: System.Collections.Generic.Dictionary`2 name: Dictionary fullName: System.Collections.Generic.Dictionary isExternal: true - name: < fullName: < - uid: System.String name: String fullName: System.String isExternal: true - name: ', ' fullName: ', ' - uid: System.Collections.Generic.List`1 name: List fullName: System.Collections.Generic.List isExternal: true - name: < fullName: < - uid: System.Int32 name: Int32 fullName: System.Int32 isExternal: true - name: '>' fullName: '>' - name: '>' fullName: '>'"
  },
  "spec/metadata_format_spec.html": {
    "href": "spec/metadata_format_spec.html",
    "title": "Doc-as-Code: Metadata Format Specification | docfx",
    "keywords": "Doc-as-Code: Metadata Format Specification 0. Introduction 0.1 Goals and Non-goals The goal of this document is to define a general format to describe language metadata for programming languages. The language metadata is designed to be language agnostic and support multiple programming language in a single metadata file. The main user scenario for language metadata is to generate reference documentation, so this document will discuss how to optimize metadata format for documentation rendering. This document does NOT discuss details of metadata format implementation of a specific programming language. 0.2 Terminology The key words MUST , MUST NOT , REQUIRED , SHALL , SHALL NOT , SHOULD , SHOULD NOT , RECOMMENDED , MAY , and OPTIONAL in this document are to be interpreted as described in RFC 2119 . Words in italic indicate they are terms previously defined in this document. 1. Items and Identifiers 1.1 Items Item is the basic unit of metadata format. From a documentation perspective, each item represents a \"section\" in the reference documentation. This \"section\" is the minimum unit that you can cross reference to, or customize in layout and content. When implementing the metadata format for your own language, you can decide which elements are items . For example, usually namespaces, classes, and methods are items . However, you can also make smaller elements such as parameters be items if you want them to be referenceable and customizable. Items can be hierarchical. One item can have other items as children . For example, in C#, namespaces and classes can have classes and/or methods as children . 1.2 Identifiers Each item has an identifier (ID) which is unique under its parent. As we're targeting to support multiple languages, there are no restrictions as to which characters are not allowed in identifiers. However, to make identifiers easier to recognize and resolve in Markdown, it's not RECOMMENDED to have whitespaces in identifiers. Markdown processor MAY implement some algorithm to tolerate whitespaces in handwritten Markdown. (Leading and trailing spaces MUST be removed from identifier.) Identifier MUST be treated as case-sensitive when comparing equality. Each item has a unique identifier (UID) which is globally unique. A UID is defined as follows: If an item does not have a parent , its UID is its ID . Otherwise, its UID is the combination of the UID of its parent , a separator and the ID of the item itself. Valid separators are . , : , / and \\ . For example, for a class String under namespace System , its ID is String and UID is System.String . Given the above definition, an item 's UID MUST starts with the UID of its parent (and any of its ancestors) and ends with the ID of itself. This is useful to quickly determine whether an item is under another item . 1.3 Alias Identifier could be very long, which makes it difficult to write by hand in Markdown. For example, it's easy to create a long ID in C# like this: Format(System.IFormatProvider,System.String,System.Object,System.Object) We can create short alias for items so that they can be referenced easily. Alias is same as ID , except: It doesn't have to be unique. One item can have multiple aliases . It's not RECOMMENDED to create an alias that has nothing to do with an item's ID . Usually an item 's alias is part of its ID so it's easy to recognize and memorize. For example, for the case above, we usually create an alias Format() . We can easily get a \"global\" alias for an item by replacing the ID part of its UID with its alias. 2. File Structure 2.1 File Format You can use any file format that can represent structural data to store metadata. However, we recommend using YAML or JSON . In this document, we use YAML in examples, but all YAML can be converted to JSON easily. 2.2 File Layout A metadata file consists of two parts: An \"item\" section and a \"reference\" section. Each section is a list of objects and each object is a key-value pair (hereafter referred to as \"property\") list that represents an item . 2.3 Item Section Though items can be hierarchical, they are flat in an item section. Instead, each item has a \"children\" property indicating its children and a \"parent\" property indicating its parent. An item object has some basic properties: Property Description uid REQUIRED . The unique identifier of the item . children OPTIONAL . A list of UIDs of the item 's children. Can be omitted if there are no children . parent OPTIONAL . The UID of the item 's parent. If omitted, metadata parser will try to figure out its parent from the children information of other items within the same file. Here is an example of a YAML format metadata file for C# Object class: items: - uid: System.Object parent: System children: - System.Object.Object() - System.Object.Equals(System.Object) - System.Object.Equals(System.Object,System.Object) - System.Object.Finalize() - System.Object.GetHashCode() - System.Object.GetType() - System.Object.MemberwiseClone() - System.Object.ReferenceEquals() - System.Object.ToString() - uid: System.Object.Object() parent: System.Object - uid: System.Object.Equals(System.Object) parent: System.Object - uid: System.Object.Equals(System.Object,System.Object) parent: System.Object - uid: System.Object.Finalize() parent: System.Object - uid: System.Object.GetHashCode() parent: System.Object - uid: System.Object.GetType() parent: System.Object - uid: System.Object.MemberwiseClone() parent: System.Object - uid: System.Object.ReferenceEquals() parent: System.Object - uid: System.Object.ToString() parent: System.Object references: ... Items SHOULD be organized based upon how they will display in documentation. For example, if you want all members of a class be displayed in a single page, put all members in a single metadata file. 2.3 Item Object In additional to the properties listed in last section, item object also has some OPTIONAL properties : Property Description id The identifier of the item . alias A list of aliases of the item . name The display name of the item . fullName The full display name of the item . In programming languages, it's usually the full qualified name. type The type of the item , such as class, method, etc. url If it's a relative URL, then it's another metadata file that defines the item . If it's an absolute URL, it means the item is coming from an external library, and the URL is the documentation page of this item . If omitted, the URL is the location of the current file. source The source code information of the item . It's an object that contains following properties : 1. repo: the remote Git repository of the source code. 2. branch: the branch of the source code. 3. revision: the Git revision of the source code. 4. path: the path to the source code file where the item is defined. 5. startLine: the start line of the item definition. 6. endLine: the end line of the item definition. Here is an example of a C# Dictionary class: - uid: System.Collections.Generic.Dictionary`2 id: Dictionary`2 alias: - Dictionary parent: System.Collections.Generic name: Dictionary<TKey, TValue> fullName: System.Collections.Generic.Dictionary<TKey, TValue> type: class url: System.Collections.Generic.Dictionary`2.yml source: repo: https://github.com/dotnet/netfx.git branch: master revision: 5ed47001acfb284a301260271f7d36d2bb014432 path: src/system/collections/generic/dictionary.cs startLine: 1 endLine: 100 2.4 Custom Properties Besides the predefined properties , item can have its own properties . One restriction is property name MUST NOT contains dots, as dot in property name will have special meaning (described in later section). 2.5 Reference Section The reference section also contains a list of items . These items serve as the references to items in the item section and won't show up in documentation. Also, a reference item doesn't need to have full properties , it just contains necessary information needed by its referrer (for example, name or URL). In metadata file, all items MUST be referenced by UID . It's RECOMMENDED to include all referenced items in reference section. This makes the file self-contained and easy to render at runtime. Many programming languages have the concept of \"template instantiation\". For example, in C#, you can create a new type List<int> from List<T> with argument int . You can create a reference for \"template instances\". For example, for a class inherited from List<int> : items: - uid: NumberList inherits: - System.Collections.Generic.List<System.Int32> references: - uid: System.Collections.Generic.List`1<System.Int32> link: @\"System.Collections.Generic.List`1\"<@\"System.Int32\"> - uid: System.Collections.Generic.List`1 name: List url: system.collections.generic.list`1.yml - uid: System.Int32 name: int url: system.int32.yml 2.6 Multiple Language Support An item may need to support multiple languages. For example, in .NET, a class can be used in C#, VB, managed C++ and F#. Different languages may have differences in properties . For example, a list of string is displayed as List<string> in C#, while List(Of string) in VB. To support this scenario, we introduce a concept of language context to allow defining different property values in different languages. If a property name is in the form of property_name.language_name , it defines the value of property_name under language_name . For example: - uid: System.Collections.Generic.Dictionary`2 name.csharp: Dictionary<TKey, TValue> name.vb: Dictionary(Of TKey, TValue) This means the name of dictionary is Dictionary<TKey, TValue> in C# and Dictionary(Of TKey, TValue) in VB. The following properties SHALL NOT be overridden in language context: uid, id, alias, children, and parent. 3. Work with Metadata in Markdown 3.1 YAML Metadata Section In a Markdown file, you can also define items using the same metadata syntax. The metadata definition MUST be in YAML format and enclosed by triple-dash lines ( --- ). Here is an example: --- uid: System.String summary: String class --- This is a **string** class. You can have multiple YAML sections inside a single Markdown file, but in a single YAML section, there MUST be only one item . The YAML metadata section does not have to contain all properties . The only property that MUST appear is \"uid\", which is used to match the same item in metadata file. The most common scenario for using YAML section is to specify which item the markdown doc belongs to. But you can also overwrite item property by defining one with the same name in YAML section. In the above example, the property \"summary\" will overwrite the same one in metadata. As with language context, the following properties SHALL NOT be overridden: uid, id, alias, children, and parent. You SHALL NOT define new item in Markdown. 3.2 Reference Items in Markdown To cross reference an item , you can use URI with xref scheme. You can either use standard link or automatic link with the above URI. For example, to cross reference System.String : [System.String](xref:System.String) <xref:System.String> Since item reference is a URI, special characters (like # , ? ) MUST be encoded . We also introduce a shorthand markdown syntax to cross reference easily: If a string starts with @ , and followed by a string enclosed by quotes ' or double quotes \" , it will be treated as an item reference. The string inside \"\" or '' is the UID of the item . Here is one example: @\"System.String\" Markdown processor MAY implement some algorithm to allow omit curly braces if ID is simple enough. For example, For reference like @\"int\" , we may also want to allow @int . When rendering references in Markdown, they will expand into a link with the item 's name as link title. You can also customize the link title using the standard syntax of Markdown: [Dictionary](xref:System.Collections.Generic.Dictionary`2)<[String](xref:System.String), [String](xref:System.String)> Will be rendered to: Dictionary < String , String > Besides UID , we also allow referencing items using ID and alias , in the Markdown processor, the below algorithm SHOULD be implemented to resolve references. Check whether the reference matches: Any identifier of current item 's children. Any alias of current item 's children. Any identifier of current item 's silbings. Any alias of current item 's silbings. A UID . A global alias ."
  },
  "spec/sdp_design_spec.html": {
    "href": "spec/sdp_design_spec.html",
    "title": "Schema-driven Document Processor(SDP) Design Spec | docfx",
    "keywords": "Schema-driven Document Processor(SDP) Design Spec 1. Overview DocFX supports different document processors to handle different kinds of input. With a new data model introduced in, a new document processor is required to support that model, even most of the code logic is the same for these processors. With this situation considered, a Schema-driven Document Processor (abbreviated to SDP below) is introduced to simplify the process. Togethor with a well defined DocFX Document Schema , SDP is able to validate and process a new data model with no extra effort needed. 2. Workflow The workflow for SDP is illustrated below. In general, the schema file, with suggested naming convention, has documentType in its name, as {documentType} .schema.json (When title is defined in the schema file, title is considered as the documentType for this schema). docfx loads the schema files from schemas subfolder in template folder, and creates processors for these schema files with per schema file per processor. With data models are processed, docfx applies templates for that documentType to these data model, as details illustrated in Template Introduction and generates output documentation."
  },
  "spec/triple_slash_comments_spec.html": {
    "href": "spec/triple_slash_comments_spec.html",
    "title": "Triple-slash (///) Code Comments Support | docfx",
    "keywords": "Triple-slash (///) Code Comments Support DocFX extracts triple-slash (///) code comments from .NET source code when running docfx metadata . Tags in triple-slash (///) code comments are converted to corresponding metadata in .NET data model. Note docfx supports DocFX Flavored Markdown syntax inside triple-slash (///) code comments. You can disable this feature by set shouldSkipMarkup when generating metadata: docfx metadata --shouldSkipMarkup . Supported tags Top level block tags Top level block tags are transformed to corresponding metadata in .NET data model. Tags Metadata name Type summary summary string remarks remarks string returns returns string value returns string exception exception List< @\"Microsoft.DocAsCode.DataContracts.ManagedReference.ExceptionInfo\" > seealso seealso List< @\"Microsoft.DocAsCode.DataContracts.ManagedReference.LinkInfo\" > see see List< @\"Microsoft.DocAsCode.DataContracts.ManagedReference.LinkInfo\" > example example List<string> Non-toplevel tags Non-toplevel tags transformed to HTML tags in DocFX. Tags Transformed Description para <p></p> b <strong></strong> i em see[@langword] <xref></xref> langwordMapping.yml lists supported language keywords in DocFX . DocFX leverages cross reference to reference language keywords. You can disable default langword resolver and apply your customized one by calling docfx build --xref yourLangword.yml --noLangKeyword see[@href] <a></a> see[@cref] <xref></xref> paramref <span class=\"paramref\"></span> typeparamref <span class=\"typeparamref\"></span> list type=\"table\" <table></table> list type=\"bullet\" <ul></ul> list type=\"number\" <ol></ol> c <code></code> code <pre><code></code></pre> Custom tags inheritdoc docfx supports a subset of the inheritdoc functionality available in Sandcastle . Specifically, it implements most of the \"Top-Level Inheritance Rules\". It does not implement: Support for the select attribute. Automatic inheritance of documentation for explicit interface implementations. Support for inline inheritdoc tags (i.e., an inheritdoc tag inside of an example tag)."
  },
  "tutorial/advanced_support_hyperlink.html": {
    "href": "tutorial/advanced_support_hyperlink.html",
    "title": "🔧 Advanced: Support Hyperlink | docfx",
    "keywords": "🔧 Advanced: Support Hyperlink In this topic, we will support hyperlinking in rtf files. Create a hyperlink in the rtf file: Open foo.rtf by Word . Add a hyperlink in content Set the link target to an existing bar.rtf Save the document. About link An author can write any valid hyperlink in the document, and then needs to run DocFX build to update file links. What is file link: The hyperlink must be a relative path and not rooted. valid: foo\\bar.rtf , ../foobar.rtf invalid: /foo.rtf , c:\\foo\\bar.rtf , http://foo.bar/ , mailto:foo@bar.foobar The file must exist. Why update file link: The story is: In foo.rtf , it has a file link to bar.rtf . In document build, bar.rtf generates a file with the name bar.html . But in foo.rtf , the link target is still bar.rtf , thus in the output folder we cannot find this file and we will get a broken link. To resolve the broken link, we need to update the link target from bar.rtf to bar.html . File link is a relative path, but we cannot track the relative path easily. So we track the normalized file path instead. What is a normalized file path : It always starts from the working folder (the folder that contains docfx.json ), and we write it as ~/ . No ../ or ./ or // Replace \\ with / . No url encoding. The path must be same as it in the file system. No anchor. Finally, a valid normalized file path looks like: ~/foo/bar.rtf . Pros Same form in different documents when the target is the same file. When file structure is: z:\\a\\b\\foo.rtf z:\\a\\b\\c\\bar.rtf z:\\a\\b\\c\\foobar.rtf Link target c/foobar.rtf in foo.rtf and link target foobar.rtf in bar.rtf is the same file. When the working folder is z:\\a\\ , the link target is always ~/b/c/foobar.rtf . Avoids differences in style when referring to the same file. For example, the following hyperlinks target the same file: a/foo.rtf , ./a/foo.rtf , a/b/../foo.rtf , a//foo.rtf , a\\foo.rtf Cons A folder with the name ~ is not supported. Prepare Open the rtf plug-in library project in Visual Studio . Add nuget packages: for plug-in: Microsoft.DocAsCode.Utility Add framework assembly reference: System.Core , System.Web , System.Xml.Linq Update rtf document processor Following the rules for hyperlink, add a FixLink help method: private static void FixLink(XAttribute link, RelativePath filePath, HashSet<string> linkToFiles) { string linkFile; string anchor = null; if (PathUtility.IsRelativePath(link.Value)) { var index = link.Value.IndexOf('#'); if (index == -1) { linkFile = link.Value; } else if (index == 0) { return; } else { linkFile = link.Value.Remove(index); anchor = link.Value.Substring(index); } var path = filePath + (RelativePath)linkFile; var file = (string)path.GetPathFromWorkingFolder(); link.Value = file + anchor; linkToFiles.Add(HttpUtility.UrlDecode(file)); } } RelativePath helps us generate the links correctly. Then add CollectLinksAndFixDocument method: private static HashSet<string> CollectLinksAndFixDocument(FileModel model) { string content = (string)((Dictionary<string, object>)model.Content)[\"conceptual\"]; var doc = XDocument.Parse(content); var links = from attr in doc.Descendants().Attributes() where \"href\".Equals(attr.Name.LocalName, StringComparison.OrdinalIgnoreCase) || \"src\".Equals(attr.Name.LocalName, StringComparison.OrdinalIgnoreCase) select attr; var path = (RelativePath)model.File; var linkToFiles = new HashSet<string>(); foreach (var link in links) { FixLink(link, path, linkToFiles); } using (var sw = new StringWriter()) { doc.Save(sw); ((Dictionary<string, object>)model.Content)[\"conceptual\"] = sw.ToString(); } return linkToFiles; } Modify Save method with report links: public SaveResult Save(FileModel model) { HashSet<string> linkToFiles = CollectLinksAndFixDocument(model); return new SaveResult { DocumentType = \"Conceptual\", ModelFile = model.File, LinkToFiles = linkToFiles.ToImmutableArray(), }; } View final RtfDocumentProcessor.cs Test and verify Build project. Copy dll to Plugins folder. Modify rtf file, create hyperlink, link to another rtf file, and save. Build with command DocFX build . Verify output html file."
  },
  "tutorial/docfx_getting_started.html": {
    "href": "tutorial/docfx_getting_started.html",
    "title": "Getting Started with *DocFX* | docfx",
    "keywords": ""
  },
  "tutorial/docfx.exe_user_manual.html": {
    "href": "tutorial/docfx.exe_user_manual.html",
    "title": "docfx.exe User Manual | docfx",
    "keywords": "Doc-as-code: docfx.exe User Manual 0. Introduction docfx.exe is used to generate documentation for programs. It has the ability to: Extract language metadata for programing languages as defined in Metadata Format Specification . Currently C# , VB and F# are supported. The language metadata will be saved with YAML format as described in YAML 1.2 . Look for available conceptual files as provided and link it with existing programs with syntax described in Section 3. Work with Metadata in Markdown . Supported conceptual files are plain text files, html files, and markdown files. Generate documentation to a. Visualize language metadata, with extra content provided by linked conceptual files using syntax described in Section 3. Work with Metadata in Markdown . b. Organize and render available conceptual files. It can be easily cross-referenced with language metadata pages. We support Docfx Flavored Markdown(DFM) for writing conceptual files. DFM supports all Github Flavored Markdown(GFM) syntax with 2 exceptions when resolving list . It also adds several new features including file inclusion , cross reference , and yaml header . For detailed description about DFM, please refer to DFM . Currently generating documentations to a client only website is supported. The generated website can be easily published to whatever platform such as Github Pages and Azure Website with no extra effort. Generating offline documentation such as PDF is also supported now. 1. Syntax docfx <command> [<args>] 2. Commands 2.0 Init command docfx init docfx init helps generate an docfx.json file. 2.1 Help command docfx help docfx help -a list available subcommands. docfx help <command> to read about a specific subcommand 2.2 Extract language metadata command docfx metadata Syntax docfx metadata [<projects>] [--property <n1>=<v1>;<n2>=<v2>] Layout |-- <metadata folder> |-- api | |-- <namespace>.yml | |-- <class>.yml |-- toc.yml |-- index.yml 2.2.1 Optional <projects> argument <projects> specifies the projects to have metadata extracted. There are several approaches to extract language metadata. From a supported file or file list Supported file extensions include .csproj , .vbproj , .sln , project.json , dll assembly file, .cs source file and .vb source file. Multiple files are separated by whitespace, e.g. docfx metadata Class1.cs a.csproj Note Glob pattern is NOT supported in command line options. From docfx.json file, as described in Section3 . If the argument is not specified, docfx.exe will try reading docfx.json under current directory. The default output folder is _site/ folder if it is not specified in docfx.json under current directory. 2.2.2 Command option --shouldSkipMarkup If adding option --shouldSkipMarkup in metadata command, it means that DocFX would not render triple-slash-comments in source code as markdown. e.g. docfx metadata --shouldSkipMarkup 2.2.3 Command option --property <n1>=<v1>;<n2>=<v2> An optional set of MSBuild properties used when interpreting project files. These are the same properties that are passed to msbuild via the /property: = ; = command line argument. For example: docfx metadata --property TargetFramework=net46 generates metadata files with .NET framework 4.6. This command can be used when the project supports multiple TargetFrameworks . 2.3 Generate documentation command docfx build Syntax docfx build [-o:<output_path>] [-t:<template folder>] docfx build generates documentation for current folder. If toc.yml or toc.md is found in current folder, it will be rendered as the top level TABLE-OF-CONTENT. As in website, it will be rendered as the top navigation bar. Path in toc.yml or toc.md are relative to the TOC file. Note Please note that homepage is not supported in toc.md . And if href is referencing to a folder , it must end with / . toc.yml syntax toc.yml is an array of items. Each item can have following properties: Property Description name Required . The title of the navigation page. href Required . Can be a folder or a file UNDER current folder. A folder must end with / . In case of a folder, TOC.md inside the folder will be rendered as second level TABLE-OF-CONTENT. As in website, it will be rendered as a sidebar. homepage The default content shown when no article is selected. TOC.yml Sample - name: Home href: articles/Home.md - name: Roslyn Wiki href: roslyn_wiki/ - name: Roslyn API href: api_roslyn/ homepage: homepages/roslyn_language_features.md TOC.md Sample ## [Home](articles/Home.md) ## [Roslyn Wiki](roslyn_wiki/) ## [Roslyn API](api_roslyn/) 2.3.1 Optional <output_path> argument The default output folder is _site/ folder 2.3.2 Optional <template folder> argument If specified, use the template from template folder Template Folder Structure |-- <template folder> |-- index.html |-- styles | |-- docascode.css | |-- docascode.js |-- template | |-- toc.html | |-- navbar.html | |-- yamlContent.html |-- favicon.ico |-- logo.ico 2.4 Generate PDF documentation command docfx pdf Syntax docfx pdf [<config_file_path>] [-o:<output_path>] docfx pdf generates PDF for the files defined in config file, if config file is not specified, docfx tries to find and use docfx.json file under current folder. Note Prerequisite: We leverage wkhtmltopdf to generate PDF. Download wkhtmltopdf and save the executable folder path to %PATH% . Or just install wkhtmltopdf using chocolatey: choco install wkhtmltopdf Current design is that each TOC file generates a corresponding PDF file. Walk through Walkthrough: Generate PDF Files to get start. If cover.md is found in a folder, it will be rendered as the cover page. 3. docfx.json Format Top level docfx.json structure is key-value pair. key is the name of the subcommand, current supported subcommands are metadata and build . 3.1 Properties for metadata Metadata section defines an array of source projects and their output folder. Each item has src and dest property. src defines the source projects to have metadata generated, which is in File Mapping Format . Detailed syntax is described in 4. Supported name-files File Mapping Format below. dest defines the output folder of the generated metadata files. Key Description src Defines the source projects to have metadata generated, which is in File Mapping Format . Relative paths are relative to the docfx.json file being used. To go up a folder use ../ . dest Defines the output folder of the generated metadata files. Relative paths are relative to the docfx.json file being used. To go up a folder use ../ . force If set to true, it would disable incremental build. shouldSkipMarkup If set to true, DocFX would not render triple-slash-comments in source code as markdown. filter Defines the filter configuration file, please go to How to filter out unwanted apis attributes for more details. useCompatibilityFileName If set to true, DocFX would keep ` in comment id instead of replacing it with - . properties Defines an optional set of MSBuild properties used when interpreting project files. These are the same properties that are passed to msbuild via the /property:name=value command line argument. Sample { \"metadata\": [ { \"src\": [ { \"files\": [\"**/*.csproj\"], \"exclude\": [ \"**/bin/**\", \"**/obj/**\" ], \"src\": \"../src\" } ], \"dest\": \"obj/docfx/api/dotnet\", \"shouldSkipMarkup\": true, \"properties\": { \"TargetFramework\": \"netstandard1.3\" } }, { \"src\": [ { \"files\": [\"**/*.js\"], \"src\": \"../src\" } ], \"dest\": \"obj/docfx/api/js\", \"useCompatibilityFileName\": true, \"properties\": { \"TargetFramework\": \"net46\" } } ] } Note Make sure to specify \"TargetFramework\": <one of the frameworks> in your docfx.json when the project is targeting for multiple platforms. 3.2 Properties for build Key Description content Contains all the files to generate documentation, including metadata yml files and conceptual md files. name-files file mapping with several ways to define it, as to be described in Section4 . The files contains all the project files to have API generated. resource Contains all the resource files that conceptual and metadata files dependent on, e.g. image files. name-files file mapping with several ways to define it, as to be described in Section4 . overwrite Contains all the conceptual files which contains yaml header with uid and is intended to override the existing metadata yml files. name-files file mapping with several ways to define it, as to be described in Section4 . globalMetadata Contains metadata that will be applied to every file, in key-value pair format. For example, you can define \"_appTitle\": \"This is the title\" in this section, and when applying template default , it will be part of the page title as defined in the template. fileMetadata Contains metadata that will be applied to specific files. name-files file mapping with several ways to define it, as to be described in Section4 . globalMetadataFiles Specify a list of JSON file path containing globalMetadata settings, as similar to {\"key\":\"value\"} . Please read Section3.2.3 for detail. fileMetadataFiles Specify a list of JSON file path containing fileMetadata settings, as similar to {\"key\":\"value\"} . Please read Section3.2.3 for detail. template The templates applied to each file in the documentation. It can be a string or an array. The latter ones will override the former ones if the name of the file inside the template collides. If omitted, embedded default template will be used. theme The themes applied to the documentation. Theme is used to customize the styles generated by template . It can be a string or an array. The latter ones will override the former ones if the name of the file inside the template collides. If omitted, no theme will be applied, the default theme inside the template will be used. xref Specifies the urls of xrefmap used by content files. Currently, it supports following scheme: http, https, ftp, file, embedded. xrefService Specifies the url patterns of xref service. Please read Section3.2.4 for detail. exportRawModel If set to true, data model to run template script will be extracted in .raw.json extension. rawModelOutputFolder Specify the output folder for the raw model. If not set, the raw model will be generated to the same folder as the output documentation. exportViewModel If set to true, data model to apply template will be extracted in .view.json extension. viewModelOutputFolder Specify the output folder for the view model. If not set, the view model will be generated to the same folder as the output documentation. dryRun If set to true, template will not be actually applied to the documents. This option is always used with --exportRawModel or --exportViewModel , so that only raw model files or view model files are generated. maxParallelism Set the max parallelism, 0 (default) is same as the count of CPU cores. markdownEngineName Set the name of markdown engine, default is dfm , other available engines are gfm and markdig . markdownEngineProperties Set the parameters for markdown engine, value should be a JSON string. noLangKeyword Disable default lang keyword, it can be downloaded from here . keepFileLink If set to true, docfx does not dereference (aka. copy) file to the output folder, instead, it saves a link_to_path property inside manifest.json to indicate the physical location of that file. A file link will be created by incremental build and copy resource file. sitemap In format SitemapOptions Specifies the options for the sitemap.xml file. disableGitFeatures Disable fetching Git related information for articles. Set to true if fetching git related information is slow for huge Git repositories. Default value is false . 3.2.1 Template s and Theme s Template s are used to transform YAML files generated by docfx to human-readable page s. A page can be a markdown file, a html file or even a plain text file. Each YAML file will be transformed to ONE page and be exported to the output folder preserving its relative path to src . For example, if page s are in HTML format, a static website will be generated in the output folder. Theme is to provide general styles for all the generated page s. Files inside a theme will be generally COPIED to the output folder. A typical usage is, after YAML files are transformed to HTML pages, well-designed CSS style files in a Theme can then overwrite the default styles defined in template , e.g. main.css . There are two ways to use custom templates and themes. To use a custom template, one way is to specify template path with --template (or -t ) command option, multiple templates must be separated by , with no spaces. The other way is to set key-value mapping in docfx.json : { ... { \"build\" : { ... \"template\": \"custom\", ... } ... } { ... { \"build\" : { ... \"template\": [\"default\", \"X:/template/custom\"], ... } ... } Note The template path could either be a zip file called <template>.zip or a folder called <template> . Warning DocFX has embedded templates: default , default(zh-cn) , pdf.default , statictoc and common . Please avoid using these as template folder name. To custom theme, one way is to specify theme name with --theme command option, multiple themes must be separated by , with no spaces. The other way is to set key-value mapping in docfx.json as similar to defining template. Also, both .zip file and folder are supported. Please refer to How to Create Custom Templates to create custom templates. Sample { \"build\": { \"content\": [ { \"files\": [\"**/*.yml\"], \"src\": \"obj/docfx\" }, { \"files\": [\"tutorial/**/*.md\", \"spec/**/*.md\", \"spec/**/toc.yml\"] }, { \"files\": [\"toc.yml\"] } ], \"resource\": [ { \"files\": [\"spec/images/**\"] } ], \"overwrite\": \"apispec/*.md\", \"externalReference\": [ ], \"globalMetadata\": { \"_appTitle\": \"DocFX website\", \"_gitContribute\": { \"repo\": \"https://github.com/org/repo\", \"branch\": \"dev\", \"apiSpecFolder\": \"docs-ref-overwrite\" } }, \"dest\": \"_site\", \"template\": \"default\" } } 3.2.2 Reserved Metadata After passing values through global metadata or file metadata, DocFX can use these metadata in templates to control the output html. Reserved metadatas: Metadata Name Type Description _appTitle string Will be appended to each output page's head title. _appFooter string The footer text. Will show DocFX's Copyright text if not specified. _appLogoPath string Logo file's path from output root. Will show DocFX's logo if not specified. Remember to add file to resource. _appFaviconPath string Favicon file's path from output root. Will show DocFX's favicon if not specified. Remember to add file to resource. _enableSearch bool Indicate whether to show the search box on the top of page. _enableNewTab bool Indicate whether to open a new tab when clicking an external link. (internal link always shows within the current tab) _disableNavbar bool Indicate whether to show the navigation bar on the top of page. _disableBreadcrumb bool Indicate whether to show breadcrumb on the top of page. _disableToc bool Indicate whether to show table of contents on the left of page. _disableAffix bool Indicate whether to show the affix bar on the right of page. _disableContribution bool Indicate whether to show the View Source and Improve this Doc buttons. _gitContribute object Customize the Improve this Doc URL button for public contributors. Use repo to specify the contribution repository URL. Use branch to specify the contribution branch. Use apiSpecFolder to specify the folder for new overwrite files. If not set, the git URL and branch of the current git repository will be used. _gitUrlPattern string Choose the URL pattern of the generated link for View Source and Improve this Doc . Supports github and vso currently. If not set, DocFX will try speculating the pattern from domain name of the git URL. _noindex bool File(s) specified are not returned in search results 3.2.3 Separated metadata files for global metadata and file metadata There're three ways to set metadata for a file in DocFX: using global metadata, it will set metadata for every file. using file metadata, it will set metadata for files that match pattern. using YAML header, it will set metadata for current file. In above ways, the later way will always overwrite the former way if the same key of metadata is set. Here we will show you how to set global metadata and file metadata using separated metadata files. Take global metadata for example, you can set globalMetadataFiles in docfx.json or --globalMetadataFiles in build command line. The usage of fileMetadataFiles is the same as globalMetadataFiles . There're some metadata file examples: globalMetadata file example { \"_appTitle\": \"DocFX website\", \"_enableSearch\": \"true\" } fileMetadata file example { \"priority\": { \"**.md\": 2.5, \"spec/**.md\": 3 }, \"keywords\": { \"obj/docfx/**\": [\"API\", \"Reference\"], \"spec/**.md\": [\"Spec\", \"Conceptual\"] }, _noindex: { \"articles/**/article.md\": true } } There're some examples about how to use separated metadata files. use globalMetadataFiles in docfx.json ... \"globalMetadataFiles\": [\"global1.json\", \"global2.json\"], ... use --globalMetadataFiles in build command line docfx build --globalMetadataFiles global1.json,global2.json use fileMetadataFiles in docfx.json ... \"fileMetadataFiles\": [\"file1.json\", \"file2.json\"], ... use --fileMetadataFiles in build command line docfx build --fileMetadataFiles file1.json,file2.json Note that, metadata set in command line will merge with metadata set in docfx.json . If same key for global metadata was set, the order to be overwritten would be(the later one will overwrite the former one): global metadata from docfx config file global metadata from global metadata files global metadata from command line If same file pattern for file metadata was set, the order to be overwritten would be(the later one will overwrite the former one): file metadata from docfx config file file metadata from file metadata files Given multiple metadata files, the behavior would be undetermined , if same key is set in these files. 3.2.4 Xref service url pattern Xref service url pattern will exact url by following steps: Replace environment variables. Syntax: {%variableName%} Process: load variable value from enviroment variables, replace the source content. Extract post pipelines. Syntax: |> pipelineName parameter1 parameter2 ... Process: load pipeline, and extract parameters, remove from url. Current pipeline only contains: removeHost , addQueryString , pluggable pipeline will be add later. Runtime replace variables. Syntax: {varName} Process: replace the source content to the value of variable (uri data encoded). e.g.: Environment variables: test = hello Available Pipeline: removeHost Variable: uid = testuid1 Url pattern: http://{%test%}.contoso.com/?uid={uid}|> removeHost It will run as following steps: Replace environment variables, http://hello.contoso.com/?uid={uid}|> removeHost . Extract post pipelines, http://hello.contoso.com/?uid={uid} , and append a post pipeline removeHost . Runtime replace variables, http://hello.contoso.com/?uid=testuid . Send request to http://hello.contoso.com/?uid=testuid , and get response from site. Run post pipeline removeHost . 3.2.5 SitemapOptions The SitemapOptions is to configure the values for generating sitemap.xml file. Property Name Type Description baseUrl string Specifies the base url for the website to be published. It MUST begin with the protocol (such as http) and end with a trailing slash. For example, https://dotnet.github.io/docfx/ . If the value is not specified, sitemap.xml will NOT be generated. lastmod DateTime Specifies the date of last modification of the file. If not specified, docfx automatically set the value to the time the file is built. changefreq enum Specifies the value of changefreq in sitemap.xml. Valid values are always , hourly , daily , weekly , monthly , yearly , never . If not specified, the default value is daily priority double Specifies the value of priority in sitemap.xml. Valid values between 0.0 and 1.0 . If not specified, the default value is 0.5 fileOptions SitemapOptions Optional. This property can be used when some specific files have different sitemap settings. It is a set of key-value pairs, where key is the glob pattern for input files, and value is the sitemap options. Order matters and the latter matching option overwrites the former ones. In the following sample settings, the yml files inside api folder are with priority 0.3 while Markdown files are with priority 0.8 and with a different baseUrl. Sample settings: \"build\": { \"sitemap\":{ \"baseUrl\": \"https://dotnet.github.io/docfx\", \"priority\": 0.1, \"changefreq\": \"monthly\", \"fileOptions\":{ \"**/api/**.yml\": { \"priority\": 0.3, \"lastmod\": \"2001-01-01\", }, \"**/GettingStarted.md\": { \"baseUrl\": \"https://dotnet.github.io/docfx/conceptual\", \"priority\": 0.8, \"changefreq\": \"daily\" } } } } Possible generated sitemap.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"> <url> <loc>https://dotnet.github.io/docfx/api/System.String.html</loc> <lastmod>2001-01-01T00:00:00.00+08:00</lastmod> <changefreq>monthly</changefreq> <priority>0.3</priority> </url> <url> <loc>https://dotnet.github.io/docfx/conceptual/GettingStarted.html</loc> <lastmod>2017-09-21T10:00:00.00+08:00</lastmod> <changefreq>daily</changefreq> <priority>0.3</priority> </url> <url> <loc>https://dotnet.github.io/docfx/ReadMe.html</loc> <lastmod>2017-09-21T10:00:00.00+08:00</lastmod> <changefreq>monthly</changefreq> <priority>0.1</priority> </url> </urlset> 3.3 Properties for pdf pdf supports ALL the properties for build , besides that, the following table lists additional properties specified for pdf only. Key Description name Specifies the prefix of the generated PDF files, e.g. PDF generated from testproject\\toc.yml is named as {name}.pdf , testproject\\api\\toc.yml is named as {name}_api.pdf . If not specified, the value of name is the folder name testproject . generatesAppendices If specified, an appendices.pdf file is generated containing all the not-in-TOC articles. keepRawFiles If specified, the intermediate html files used to generate the PDF are not deleted after the PDF has been generated. wkhtmltopdf Contains additional options specific to wkhtmltopdf which is used internally to generate the PDF files. coverTitle The name of the bookmark to use for the cover page. If omitted, \"Cover Page\" will be used. tocTitle The name of the bookmark to use for the \"Table of Contents\". If omitted, \"Table of Contents\" will be used. outline The type of outline to use. Valid values are NoOutline , DefaultOutline , WkDefaultOutline . If not specified, the default value is DefaultOutline . If WkDefaultOutline is specified, --outline is passed to wkhtmltopdf; otherwise --no-outline is passed to wkhtmltopdf. noStdin Do not use --read-args-from-stdin for the wkhtmltopdf. Html input file names are set using the command line. It has been introduced to use in the Azure pipeline build. Can cause maximum allowed arguments length overflow if too many input parts (like Appendices, TocTitle, CoverPageTitle) were set for certain html source file. excludeDefaultToc If true, excludes the table of contents (generated by DocFX) in the PDF file. 3.3.1 Properties for the wkhtmltopdf Key Key Description filePath The path and file name of a wkhtmltopdf.exe compatible executable. additionalArguments Additional arguments that should be passed to the wkhtmltopdf executable. For example, pass --enable-local-file-access if you are building on a local file system. This will ensure that the supporting *.js and *.css files are loaded when rendering the HTML being converted to PDF. 4. Supported File Mapping Format There are several ways to define file mapping. 4.1 Array Format This form supports multiple file mappings, and also allows additional properties per mapping. Supported properties: Property Name Description files REQUIRED . The file or file array, glob pattern is supported. name Obsoleted , please use dest . exclude The files to be excluded, glob pattern is supported. cwd Obsoleted , please use src . src Specifies the source directory. If omitted, the directory of the config file will be used. It is possible to set this path relative or absolute. Use the relative path defintion when you want to refer to files in relative folders while want to keep folder structure. e.g. set src to .. . When you prefere absolut path, maybe it is more meaningful to use System Enviroment variables. dest The folder name for the generated files. version Version name for the current file mapping. If not set, treat the current file-mapping item as in default version. Mappings with the same version name will be built together. Cross reference doesn't support cross different versions. caseSensitive TOBEIMPLEMENTED . Default value is false . If set to true , the glob pattern is case sensitive. e.g. *.txt will not match 1.TXT . For OS Windows, file path is case insensitive while for Linux/Unix, file path is case sensitive. This option offers user the flexibility to determine how to search files. supportBackslash TOBEIMPLEMENTED . Default value is true . If set to true , \\ will be considered as file path separator. Otherwise, \\ will be considered as normal character if escape is set to true and as escape character if escape is set to false . If escape is set to true , \\\\ should be used to represent file path separator. escape TOBEIMPLEMENTED . Default value is false . If set to true , \\ character is used as escape character, e.g. \\{\\}.txt will match {}.txt . \"key\": [ {\"files\": [\"file1\", \"file2\"], \"dest\": \"dest1\"}, {\"files\": \"file3\", \"dest\": \"dest2\"}, {\"files\": [\"file4\", \"file5\"], \"exclude\": [\"file5\"], \"src\": \"folder1\"}, {\"files\": \"Example.yml\", \"src\": \"v1.0\", \"dest\":\"v1.0/api\", \"version\": \"v1.0\"}, {\"files\": \"Example.yml\", \"src\": \"v2.0\", \"dest\":\"v2.0/api\", \"version\": \"v2.0\"} ] 4.2 Compact Format \"key\": [\"file1\", \"file2\"] 4.3 Glob Pattern DocFX uses Glob to support glob pattern in file path. It offers several options to determine how to parse the Glob pattern: caseSensitive : Default value is false . If set to true , the glob pattern is case sensitive. e.g. *.txt will not match 1.TXT . For OS Windows, file path is case insensitive while for Linux/Unix, file path is case sensitive. This option offers user the flexibility to determine how to search files. supportBackslash : Default value is true . If set to true , \\ will be considered as file path separator. Otherwise, \\ will be considered as normal character if escape is set to true and as escape character if escape is set to false . If escape is set to true , \\\\ should be used to represent file path separator. escape : Default value is false . If set to true , \\ character is used as escape character, e.g. \\{\\}.txt will match {}.txt . In general, the glob pattern contains the following rules: * matches any number of characters, but not / ? matches a single character, but not / ** matches any number of characters, including / , as long as it's the only thing in a path part {} allows for a comma-separated list of OR expressions SAMPLES 5. Q & A Do we support files outside current project folder(the folder where docfx.json exists)? A: YES. DO specify src and files outside of current folder will be copied to output folder keeping the same relative path to src . Do we support output folder outside current project folder(the folder where docfx.json exists)? A: YES. Do we support referencing files outside of current project folder(the folder where docfx.json exists)? A: NO."
  },
  "tutorial/howto_add_a_customized_post_processor.html": {
    "href": "tutorial/howto_add_a_customized_post_processor.html",
    "title": "How-to: Add a customized post-processor | docfx",
    "keywords": "How-to: Add a customized post-processor We provide the ability to process output files by adding a customized post-processor. In DocFX, the index file for full-text-search is generated by one post-processor named ExtractSearchIndex . In this topic, we will show how to add a customized post-processor. Step0: Preparation Create a new C# class library project in Visual Studio . Add nuget packages: System.Collections.Immutable with version 1.3.1 Microsoft.Composition with version 1.0.31 Add Microsoft.DocAsCode.Plugins If you are building DocFX from source code, add this reference to the project, otherwise add the nuget package Microsoft.DocAsCode.Plugins with the same version as DocFX. Step1: Create a new class (MyProcessor.cs) with the following code: [Export(nameof(MyProcessor), typeof(IPostProcessor))] public class MyProcessor : IPostProcessor { // TODO: implements IPostProcessor } Step2: Update global metadata public ImmutableDictionary<string, object> PrepareMetadata(ImmutableDictionary<string, object> metadata) { // TODO: add/remove/update property from global metadata return metadata; } In this method, we can update the global metadata before building all the files declared in docfx.json . Otherwise, you can just return the metadata from parameters if you don't need to change global metadata. Using ExtractSearchIndex for example, we add \"_enableSearch\": true in global metadata. The default template would then know it should load a search box in the navbar. Step3: Process all the files generated by DocFX public Manifest Process(Manifest manifest, string outputFolder) { // TODO: add/remove/update all the files included in manifest return manifest; } Input for the method manifest contains a list of all files to process, and outputFolder specifies the output folder where our static website will be placed. We can implement customized operations here to process all files generated by DocFX. Note Post-processor aims to process the output files, so the FileModel can't be accessed in this phase. If some metadata is needed here, an option is to save it in FileModel.ManifestProperties in build phase, then access it through ManifestItem.Metadata . Another option is to save it somewhere in output files, like HTML's <meta> Tag. Using ExtractSearchIndex for example again, we traverse all HTML files, extract key words from these HTML files and save a file named index.json under the outputFolder . Finally we return the manifest which is not modified. Step4: Build your project and copy the output dll files to: Global: the folder with name Plugins under DocFX.exe Non-global: the folder with name Plugins under a template folder, then run DocFX build command with parameter -t {template} . Hint : DocFX can merge templates, so we can specify multiple template folders as DocFX build -t {templateForRender},{templateForPlugins} . Each of the template folders should have a subfolder named Plugins with exported assemblies. Step5: Add your post processor in docfx.json In this step, we need to enable the processor by adding its name in docfx.json . Here is an example: { \"build\": { ... \"postProcessors\": [\"OutputPDF\", \"BeautifyHTML\", \"OutputPDF\"] } } As you can see, the postProcessors is an array, which means it could have multiple processors. It needs to be pointed out that the order of postProcessors written in docfx.json is also the order to process output files. In the above example, DocFX will run OutputPDF first, then BeautifyHTML , and then OutputPDF again. If you want to enable the post processors without changing docfx.json , you can use the build command option like docfx build --postProcessors=OutputPDF,BeautifyHTML,OutputPDF . One more thing need to be noted: the build command option postProcessors would override the corresponding configuration in docfx.json ."
  },
  "tutorial/howto_build_your_own_type_of_documentation_with_custom_plug-in.html": {
    "href": "tutorial/howto_build_your_own_type_of_documentation_with_custom_plug-in.html",
    "title": "How-to: Build your own type of documentation with a custom plug-in | docfx",
    "keywords": "How-to: Build your own type of documentation with a custom plug-in In this topic we will create a plug-in to convert some simple rich text format files to html documents. Goal and limitation In scope: Our input will be a set of rtf files with .rtf as the file extension name. The rtf files will be built as html document. Out of scope: Picture or other object in rtf files. Hyperlink in rtf files. (in the advanced tutorial , we will describe how to support hyperlinks in a custom plugin.) Metadata and title. Preparation Create a new C# class library project in Visual Studio , targets .NET Framework 4.7.2 or later. Add nuget packages: System.Collections.Immutable with version 1.3.1 or later (if not already included in your .NET Framework target version) Microsoft.Composition with version 1.0.31 Add Microsoft.DocAsCode.Plugins and Microsoft.DocAsCode.Common If building DocFX from source code then add a reference to the project, otherwise add the nuget packages with the same version as DocFX. Add framework assembly references: PresentationCore , PresentationFramework , WindowsBase . (This step is optional in Visual Studio 2017 or above) Add a project for converting rtf to html: Clone project MarkupConverter , and reference it. Copy the code file CSharp/parallel/ParallelExtensionsExtras/TaskSchedulers/StaTaskScheduler.cs from DotNet Samples Create a document processor Responsibility of the document processor Declare which file can be handled. Load from the file to the object model. Provide build steps. Report document type, file links and xref links in document. Update references. Create our RtfDocumentProcessor Create a new class (RtfDocumentProcessor.cs) with the following code: [Export(typeof(IDocumentProcessor))] public class RtfDocumentProcessor : IDocumentProcessor { // todo : implements IDocumentProcessor. } Declare that we can handle the .rtf file: public ProcessingPriority GetProcessingPriority(FileAndType file) { if (file.Type == DocumentType.Article && \".rtf\".Equals(Path.GetExtension(file.File), StringComparison.OrdinalIgnoreCase)) { return ProcessingPriority.Normal; } return ProcessingPriority.NotSupported; } Here we declare this processor can handle any .rtf file in the article category with normal priority. When two or more processors compete for the same file, DocFX will give it to the higher priority one. Unexpected : two or more processor declare for the same file with same priority. Load our rtf file by reading all text: public FileModel Load(FileAndType file, ImmutableDictionary<string, object> metadata) { var content = new Dictionary<string, object> { [\"conceptual\"] = File.ReadAllText(Path.Combine(file.BaseDir, file.File)), [\"type\"] = \"Conceptual\", [\"path\"] = file.File, }; var localPathFromRoot = PathUtility.MakeRelativePath(EnvironmentContext.BaseDirectory, EnvironmentContext.FileAbstractLayer.GetPhysicalPath(file.File)); return new FileModel(file, content) { LocalPathFromRoot = localPathFromRoot, }; } We use Dictionary<string, object> as the data model, similar to how ConceptualDocumentProcessor stores the content of markdown files. Implement Save method as follows: public SaveResult Save(FileModel model) { return new SaveResult { DocumentType = \"Conceptual\", FileWithoutExtension = Path.ChangeExtension(model.File, null), }; } BuildSteps property can provide several build steps for the model. We suggest implementing this in the following manner: [ImportMany(nameof(RtfDocumentProcessor))] public IEnumerable<IDocumentBuildStep> BuildSteps { get; set; } Name property is used to display in the log, so give any constant string you like. e.g.: public string Name => nameof(RtfDocumentProcessor); Since we don't support hyperlink, keep the UpdateHref method empty. public void UpdateHref(FileModel model, IDocumentBuildContext context) { } View the final RtfDocumentProcessor.cs Create a document build step Responsibility of the build step Reconstruct documents via the Prebuild method, e.g.: remove some document according to a certain rule. Transform document content via Build method, e.g.: transform rtf content to html content. Transform more content required by all document processed via the PostBuild method, e.g.: extract the link text from the title of another document. About build order: For all documents in one processor always Prebuild -> Build -> Postbuild . For all documents in one processor always invoke Prebuild by BuildOrder . For each document in one processor always invoke Build by BuildOrder . For all documents in one processor always invoke Postbuild by BuildOrder . e.g.: Document processor X has two steps: A (with BuildOrder=1), B (with BuildOrder=2). When X is handling documents [D1, D2, D3], the invoke order is as follows: A.Prebuild([D1, D2, D3]) returns [D1, D2, D3] B.Prebuild([D1, D2, D3]) returns [D1, D2, D3] Parallel( A.Build(D1) -> B.Build(D1), A.Build(D2) -> B.Build(D2), A.Build(D3) -> B.Build(D3) ) A.Postbuild([D1, D2, D3]) B.Postbuild([D1, D2, D3]) Create our RtfBuildStep: Create a new class (RtfBuildStep.cs), and declare it is a build step for RtfDocumentProcessor : [Export(nameof(RtfDocumentProcessor), typeof(IDocumentBuildStep))] public class RtfBuildStep : IDocumentBuildStep { // todo : implements IDocumentBuildStep. } In the Build method, convert rtf to html: private readonly TaskFactory _taskFactory = new TaskFactory(new StaTaskScheduler(1)); public void Build(FileModel model, IHostService host) { string content = (string)((Dictionary<string, object>)model.Content)[\"conceptual\"]; content = _taskFactory.StartNew(() => RtfToHtmlConverter.ConvertRtfToHtml(content)).Result; ((Dictionary<string, object>)model.Content)[\"conceptual\"] = content; } Implement other methods: public int BuildOrder => 0; public string Name => nameof(RtfBuildStep); public void Postbuild(ImmutableList<FileModel> models, IHostService host) { } public IEnumerable<FileModel> Prebuild(ImmutableList<FileModel> models, IHostService host) { return models; } View the final RtfBuildStep.cs Enable plug-in Build our project. Copy the output dll files to: Global: a folder you create, named Plugins under the folder where DocFX.exe resides. Non-global: a folder you create with the name Plugins under a template folder. Then run DocFX build command with parameter -t {template} . Hint : DocFX can merge templates so create a template that only contains the Plugins folder, then run the command DocFX build with parameter -t {templateForRender},{templateForPlugins} . Build document Run command DocFX init and set the source article with **.rtf . Run command DocFX build ."
  },
  "tutorial/howto_create_custom_template.html": {
    "href": "tutorial/howto_create_custom_template.html",
    "title": "How-to: Create A Custom Template | docfx",
    "keywords": "How-to: Create A Custom Template Templates are organized as a zip package or a folder. The file path (without the .zip extension) of the zip package or the path of the folder is considered to be the template name. Quickstart Let's create a template to transform Markdown files into a simple html file. Step 1. Create a template folder Create a folder for the template, for example, c:/docfx_howto/simple_template . Step 2. Add Renderer file Create a file conceptual.html.primary.tmpl under the template folder with the following content: {{{conceptual}}} Now a simple custom template is created. You may notice that DocFX reports a warning message saying that: Warning: [Build Document.Apply Templates]There is no template processing document type(s): Toc . It is because our custom template only specifies how to handle document with type conceptual . In the documentation project, run docfx build docfx.json -t c:/docfx_howto/simple_template --serve . The -t command option specifies the template name(s) used by the current build. Open http://localhost:8080 and you can see a simple web page as follows: Add Preprocessor file Step 3. Add Preprocessor file Sometimes the input data model is not exactly what Renderer wants, you may want to add some properties to the data model, or modify the data model a little bit before applying the Renderer file. This can be done by creating a Preprocessor file. Create a file conceptual.html.primary.js under the template folder with the following content: exports.transform = function (model) { model._extra_property = \"Hello world\"; return model; } Update the file conceptual.html.primary.tmpl with the following content: <h1>{{_extra_property}}</h1> {{{conceptual}}} In the documentation project, run docfx build docfx.json -t c:/docfx_howto/simple_template --serve . Open http://localhost:8080 and you can see _extra_property is added to the web page. Merge template with default template DocFX contains some embedded template resources that you can refer to directly. You can use docfx template list to list available templates provided by DocFX. Take default template as an example. Run docfx template export default . It exports what's inside default template into the folder _exported_templates . You can see that there are sets of Preprocessor and Renderer files to deal with different types of documents. DocFX supports specifying multiple templates for a documentation project. That allows you to leverage the default template for handling other types of documents, together with your custom template. When dealing with multiple templates, DocFX merges the files inside these templates. The principle for merging is: if a file name collides then the file in the latter template overwrites the one in the former template. For example, you can merge default template and your custom template by calling docfx build docfx.json -t default,c:/docfx_howto/simple_template . Multiple templates are split by a comma , in the command line. Or you can define it in docfx.json by: \"build\": { \"template\": [ \"default\", \"c:/docfx_howto/simple_template\" ] } In the documentation project, run docfx build docfx.json -t default,c:/docfx_howto/simple_template --serve . Now the warning message There is no template processing document type(s): Toc disappears because the default template contains Renderer to handle TOC files. Open http://localhost:8080/toc.html and you can see a toc web page. Tip Run docfx template export default to view what's inside the default template. Note It is possible that DocFX updates its embedded templates when a new version is released. So please make sure to re-export the template if you overwrite or are dependent on it in your custom template. Extension for Preprocessor file If you want to modify some properties based on DocFX default template's Preprocessor , you can use Preprocessor extension file to achieve this. For example, if you want to add a property to the managed reference's data model after default template's Preprocessor , you can update the file ManagedReference.extension.js in your custom template with the following content: /** * This method will be called at the start of exports.transform in ManagedReference.html.primary.js */ exports.preTransform = function (model) { return model; } /** * This method will be called at the end of exports.transform in ManagedReference.html.primary.js */ exports.postTransform = function (model) { model._extra_property = \"Hello world\"; return model; } Compared with modifying ManagedReference.html.primary.js directly, you needn't worry about merging your custom templates with DocFX's embedded templates when DocFX updates."
  },
  "tutorial/howto_customize_docfx_flavored_markdown.html": {
    "href": "tutorial/howto_customize_docfx_flavored_markdown.html",
    "title": "How-to: Customize DFM Engine | docfx",
    "keywords": "How-to: Customize DFM Engine Warning Currently, there're two markdown engines in DocFX: dfm engine and markdig engine . This tutorial is about how to customize dfm engine, so it doesn't work with markdig engine. markdig engine will be enabled only when docfx.json contains markdownEngineName: markdig in build configuration part, otherwise dfm engine will be enabled. Customize Renderer DocFX Flavored Markdown introduced @Microsoft.DocAsCode.Dfm.IDfmCustomizedRendererPartProvider from v2.17. In older version, you need to define a new markdown renderer and export a new markdown service . Now, you can customize a part of renderer as a DocFX plugin. Default rendering for block code For standard markdown, block code is following: ```cs Console.WriteLine(); ``` And the html will be: <pre><code class=\"lang-cs\">Console.WriteLine(); </code></pre> Set goal Now we want any csharp code ( cs , c# , csharp ) will generate following html: <pre><code class=\"lang-csharp\">Console.WriteLine(); </code></pre> Create customize rendering plugin project To complete this goal, we need to create a customized rendering plugin. Create a project, set project names. Add required nuget package: Microsoft.DocAsCode.Dfm with version >= 2.17, Microsoft.Composition with version 1.0.31. Create a class, for example with name CustomBlockCodeRendererPart . Inherit @\"Microsoft.DocAsCode.Dfm.DfmCustomizedRendererPartBase`3\" (which implements @Microsoft.DocAsCode.Dfm.IDfmCustomizedRendererPart). Implements renderer part class like following: public class CustomBlockCodeRendererPart : DfmCustomizedRendererPartBase<IMarkdownRenderer, MarkdownCodeBlockToken, MarkdownBlockContext> { public override string Name => \"MyFirstCustomRendererPart\"; public override bool Match(IMarkdownRenderer renderer, MarkdownCodeBlockToken token, MarkdownBlockContext context) { return token.Lang == \"cs\" || token.Lang == \"c#\" || token.Lang == \"csharp\"; } public override StringBuffer Render(IMarkdownRenderer renderer, MarkdownCodeBlockToken token, MarkdownBlockContext context) { StringBuffer result = \"<pre><code class=\\\"\"; result += renderer.Options.LangPrefix; result += \"csharp\"; result += \"\\\">\"; result += token.Code; result += \"\\n</code></pre>\"; return result; } } Tip If your part require dispose some resource, please implement IDisposable . Create another class, for example with name CustomBlockCodeRendererPartProvider Implements @Microsoft.DocAsCode.Dfm.IDfmCustomizedRendererPartProvider and export like following: [Export(typeof(IDfmCustomizedRendererPartProvider))] public class CustomBlockCodeRendererPartProvider : IDfmCustomizedRendererPartProvider { public IEnumerable<IDfmCustomizedRendererPart> CreateParts(IReadOnlyDictionary<string, object> parameters) { yield return new CustomBlockCodeRendererPart(); } } Build the project. Enable customize rendering plugin Copy output assemblies to x\\plugins, x is any folder. Run docfx.exe with template x ( details ) Customize Markdown Extension In DocFX Flavored Markdown, we can add new markdown extensions by existing plugin system. Compare with markdown lite In markdown lite, we can customize markdown extension by following steps: Create a new token Create a new rule Create a new renderer Create a new engine builder In DocFX Flavored Markdown, we introduced @Microsoft.DocAsCode.Dfm.IDfmEngineCustomizer from v2.17. Now, we need to following step: Create a new token Create a new rule Create a new renderer part Create a new renderer part provider Create a new DFM engine customizer Difference: DFM markdown extension is a part plugin, markdown lite is a whole engine plugin. You can combine two or more DFM markdown extensions, but you must choose one of markdown lite engine plugin. How to create a new markdown extension by plugin Define markdown syntax (same with markdown lite ). Select token kind (same with markdown lite ). Define token (same with markdown lite ). Define rule (same with markdown lite ). Create a new renderer part. public sealed class LabelRendererPart : DfmCustomizedRendererPartBase<IMarkdownRenderer, MarkdownMyLabelBlockToken, MarkdownBlockContext> { public override string Name => \"LabelRendererPart\"; public override bool Match(IMarkdownRenderer renderer, MarkdownMyLabelBlockToken token, MarkdownBlockContext context) => true; public override StringBuffer Render(IMarkdownRenderer renderer, MarkdownMyLabelBlockToken token, MarkdownBlockContext context) => \"<div id=\\\"\" + token.Label + \"\\\"></div>\"; } Create a new renderer part provider. [Export(typeof(IDfmCustomizedRendererPartProvider))] public class LabelRendererPartProvider : IDfmCustomizedRendererPartProvider { public IEnumerable<IDfmCustomizedRendererPart> CreateParts(IReadOnlyDictionary<string, object> parameters) { yield return new LabelRendererPart(); } } Create a new DFM engine customizer. [Export(typeof(IDfmEngineCustomizer))] public class MyDfmEngineCustomizer : IDfmEngineCustomizer { public void Customize(DfmEngineBuilder builder, IReadOnlyDictionary<string, object> parameters) { var index = builder.BlockRules.FindIndex(r => r is MarkdownHeadingBlockRule); builder.BlockRules = builder.BlockRules.Insert(index, new MyHeadingRule()); } } Build project. Enable and test your plugin."
  },
  "tutorial/howto_filter_out_unwanted_apis_attributes.html": {
    "href": "tutorial/howto_filter_out_unwanted_apis_attributes.html",
    "title": "How-to: Filter Out Unwanted APIs or Attributes | docfx",
    "keywords": ""
  },
  "tutorial/intro_markdown_lite.html": {
    "href": "tutorial/intro_markdown_lite.html",
    "title": "Markdown Lite | docfx",
    "keywords": "Markdown Lite Introduction Markdown lite is a simple markdown tool to markup md file. Design goal We write this tool for good extensibility, so our implementation should obey following principles: Extensibility: Support markdown syntax extension. Support validation extension. Correctness: We follow GFM syntax, but when some rules are too hard to implement, just breaking. Performance: Performance is not our major concern. Steps There are three steps when calling markup method : Parse Rewrite or validate Render Step 1: Parse In this step, it will parse markdown text to tokens . The parser is based on rules , which make up the context . For example, heading token is created by heading rule , the heading rule is belonging to block context . Step 2: Rewrite or validate In this step, it will walk through all tokens , we can change it to another, or just validate. For example, we can create a rewriter to change all heading token with depth + 1: MarkdownTokenRewriterFactory.FromLambda<IMarkdownRewriteEngine, MarkdownHeadingBlockToken>( (engine, token) => new MarkdownHeadingBlockToken(token.Rule, token.Context, token.Content, token.Id, token.Depth + 1, token.SourceInfo); Step 3: Render In this step, it renders models to text content (html format by default). To simplify extension, we created an adapter , the adapter invoke methods by following rules: Method name is Render Instance method Return type is @Microsoft.DocAsCode.MarkdownLite.StringBuffer The count of parameters is 3, and types are following: @Microsoft.DocAsCode.MarkdownLite.IMarkdownRenderer or any type implements it. @Microsoft.DocAsCode.MarkdownLite.IMarkdownToken or any type implements it. @Microsoft.DocAsCode.MarkdownLite.IMarkdownContext or any type implements it. Always invoke the best overloaded method (The best is defined by binder ). Engine and engine builder Engine is a set of parser, rewriter and renderer. It can markup a markdown file to html file (or others). But it cannot be invoked in parallel. So we create an engine builder . It defines all the rules of parser, rewriter and renderer. It can create instances when needed. How to customize markdown syntax Define markdown syntax Define markdown: : My label should be rendered as following html: <div id=\"My label\"></div> Select token kind First of all, we should select the context for this rule. And in this goal, the new line is required. So it should be a block token , all of the names for class should contain Block . Define token Create a token class like following: public class MarkdownMyLabelBlockToken : IMarkdownToken { public MarkdownMyLabelBlockToken(IMarkdownRule rule, IMarkdownContext context, string label, SourceInfo sourceInfo) { Rule = rule; Context = context; Label = label; SourceInfo = sourceInfo; } public IMarkdownRule Rule { get; } public IMarkdownContext Context { get; } public string Label { get; } public SourceInfo SourceInfo { get; } } Define rule Create a rule class as following: public class MarkdownMyLabelBlockRule : IMarkdownRule { public virtual string Name => \"My Label\"; public virtual Regex LabelRegex { get; } = new Regex(\"^\\: *([^\\n]+?) *(?:\\n+|$)\"); public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context) { var match = LabelRegex.Match(context.CurrentMarkdown); if (match.Length == 0) { return null; } var sourceInfo = context.Consume(match.Length); return new MarkdownMyLabelBlockToken(this, parser.Context, match.Groups[1].Value, sourceInfo); } } Define renderer Create a renderer class as following: public class MyRenderer : HtmlRenderer { public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownMyLabelBlockToken token, IMarkdownContext context) { return StringBuffer.Empty + \"<div id=\\\"\" + token.Label + \"\\\"></div>\"; } } Define engine builder Create an engine builder class as following: public class MyEngineBuilder : GfmEngineBuilder { public MyEngineBuilder(Options options) : base(options) { BlockRules = BlockRules.Insert(0, new MarkdownMyLabelBlockRule()); } } Markup it! Then use your custom markdown in your code: public string MarkupMyMarkdown(string markdown) { var builder = new MyEngineBuilder(new Options()); var engine = builder.CreateEngine(new MyRender()) return engine.Markup(markdown); }"
  },
  "tutorial/intro_overwrite_files.html": {
    "href": "tutorial/intro_overwrite_files.html",
    "title": "Overwrite Files | docfx",
    "keywords": "Overwrite Files Introduction DocFX supports processing Markdown files, as well as structured data model in YAML or JSON format. We call Markdown files Conceptual File s, and the structured data model files Metadata File s. Current supported Metadata File s include: YAML files presenting managed reference model following Metadata Format for .NET Languages . Swagger JSON files presenting Swagger REST API model following Swagger Specification Version 2.0 . Inside DocFX, both Conceptual File s and Metadata File s are represented as Model s with different properties. Details on Model structure for these files are described in Data model inside DocFX section. DocFX introduces the concept of Overwrite File to modify or add properties to Model s without changing the input Conceptual File s and Metadata File s. The format of Overwrite File s Overwrite File s are Markdown files with multiple Overwrite Section s starting with YAML header block. A valid YAML header for an Overwrite Section MUST take the form of valid YAML set between triple-dashed lines and start with property uid . Here is a basic example of an Overwrite Section : --- uid: microsoft.com/docfx/Contacts some_property: value --- Further description for `microsoft.com/docfx/Contacts` Each Overwrite Section is transformed to Overwrite Model inside DocFX. For the above example, the Overwrite Model represented in YAML format is: uid: microsoft.com/docfx/Contacts some_property: value conceptual: <p><b>Content</b> in Markdown</p> Anchor *content *content is the keyword invented and used specifically in Overwrite File s to represent the Markdown content following YAML header. We leverage Anchors syntax in YAML specification for *content . The value for *content is always transformed from Markdown content to HTML. When *content is not used, the Markdown content below YAML header will be set to conceptual property; When *content is used, the Markdown content below YAML header will no longer be set to conceptual property. With *content , we can easily add Markdown content to any properties. --- uid: microsoft.com/docfx/Contacts footer: *content --- Footer for `microsoft.com/docfx/Contacts` In the above example, the value for *content is <p>Footer for <code>microsoft.com/docfx/Contacts</code></p> , and the Overwrite Model represented in YAML format is: uid: microsoft.com/docfx/Contacts footer: <p>Footer for <code>microsoft.com/docfx/Contacts</code></p> uid for an Overwrite Model stands for the Unique IDentifier of the Model it will overwrite. So it is allowed to have multiple Overwrite Section s with YAML Header containing the same uid . For one Overwrite File , the latter Overwrite Section overwrites the former one with the same uid . For different Overwrite File s, the order of overwrite is Undetermined . So it is suggested to have Overwrite Sections with the same uid in the same Overwrite File . Note Multiple Overwrite Section s in one file doesn't work in markdig markdown engine. You should remove \"markdownEngineName\": \"markdig\", from docfx.json to support this feature. When processing Conceptual File s and Metadata File s, Overwrite Model s with the same uid are applied to the processed Model s. Different Model s have different overwrite principles, Overwrite principles section describes the them in detail. Apply Overwrite File s Inside docfx.json , overwrite is used to specify the Overwrite File s. Overwrite principles As a general principle, uid is always the key that an Overwrite Model find the Model it is going to overwrite. So a Model with no uid defined will never get overwritten. Different types of files produce different Model s. The quickest way to get an idea of what the Model looks like is to run: docfx build --exportRawModel --exportRawModel exports Model in JSON format with .raw.json extension. The basic principle of Overwrite Model is: It keeps the same data structure as the Model it is going to overwrite If the property is defined in Model , please refer Data model inside DocFX for the specific overwrite behavior for a specific property. If the property is not defined in Model , it is added to Model Data model inside DocFX Managed reference model Key Type Overwrite behavior uid uid Merge key. assemblies string[] Ignore. attributes Attribute [] Ignore. children uid[] Ignore. documentation Source Merge. example string[] Replace. exceptions Exception [] Merge keyed list. fullName string Replace. fullName. string Replace. id string Replace. implements uid[] Ignore. inheritance uid[] Ignore. inheritedMembers uid[] Ignore. isEii boolean Replace. isExtensionMethod boolean Replace. langs string[] Replace. modifiers. string[] Ignore. name string Replace. name. string Replace. namespace uid Replace. overridden uid Replace. parent uid Replace. platform string[] Replace. remarks markdown Replace. see LinkInfo [] Merge keyed list. seealso LinkInfo [] Merge keyed list. source Source Merge. syntax Syntax Merge. summary markdown Replace. type string Replace. Source Property Type Overwrite behavior base string Replace. content string Replace. endLine integer Replace. id string Replace. isExternal boolean Replace. href string Replace. path string Replace. remote GitSource Merge. startLine integer Replace. GitSource Property Type Overwrite behavior path string Replace. branch string Replace. repo url Replace. commit Commit Merge. key string Replace. Commit Property Type Overwrite behavior committer User Replace. author User Replace. id string Replace. message string Replace. User Property Type Overwrite behavior name string Replace. email string Replace. date datetime Replace. Exception Property Type Overwrite behavior type uid Merge key. description markdown Replace. commentId string Ignore. LinkInfo Property Type Overwrite behavior linkId uid or href Merge key. altText markdown Replace. commentId string Ignore. linkType enum( CRef or HRef ) Ignore. Syntax Property Type Overwrite behavior content string Replace. content. string Replace. parameters Parameter [] Merge keyed list. typeParameters Parameter [] Merge keyed list. return Parameter Merge. Parameter Property Type Overwrite behavior id string Merge key. description markdown Replace. attributes Attribute [] Ignore. type uid Replace. Attribute Property Type Overwrite behavior arguments Argument [] Ignore. ctor uid Ignore. namedArguments NamedArgument [] Ignore. type uid Ignore. Argument Property Type Overwrite behavior type uid Ignore. value object Ignore. NamedArgument Property Type Overwrite behavior name string Ignore. type string Ignore. value object Ignore. REST API model Key Type Overwrite behavior children REST API item model Overwrite when uid of the item model matches summary string Overwrite description string Overwrite REST API item model Key Type Overwrite behavior uid string Key Conceptual model Key Type Overwrite behavior title string Overwrite rawTitle string Overwrite conceptual string Overwrite"
  },
  "tutorial/intro_rest_api_documentation.html": {
    "href": "tutorial/intro_rest_api_documentation.html",
    "title": "Introduction to REST API Documentation | docfx",
    "keywords": ""
  },
  "tutorial/intro_template.html": {
    "href": "tutorial/intro_template.html",
    "title": "Introduction to the DocFX Template System | docfx",
    "keywords": "Introduction to the DocFX Template System The DocFX template system provides a flexible way of defining and using templates to control how the final output files are rendered. These files provide the content used to publish a DocFx-generated web site. Note that this is different than the HTML templates discussed in Walkthrough Advanced: Customize Your Website , which are used to control the styling applied to the web site. As the following DocFX workflow shows, DocFX loads the set of files and transforms them into different data models using different types of Document Processor s. Afterwards, the template system loads these data models, and transforms them into output files based on the document type of the data model. Each file belongs to a document type . For example, the document type for Markdown files is conceptual , and the document type for toc.md files is Toc . For a specific Template , each document type can have several Renderer s. For a specific file, the template system picks the corresponding Renderer s to render the input data model into output files. Renderer Renderer s are files written in a specific templating language. It is used to transform the input data model into output files. Currently DocFX supports the following templating languages: Mustache templating language Liquid templating language Naming rule for a Renderer file The naming rule for a Renderer file is: <document_type>.<output_extension>[.primary].<template_extension> . <document_type> is the document type current Renderer responsible to. <output_extension> defines the extension of the output files going through current Renderer . For example, conceptual.html.tmpl transforms file1.md into output file file1.html , and toc.json.tmpl transforms toc.md into output file toc.json . [.primary] is optional. It is used when there are multiple Renderer s with different extension for one particular document type. The output file transformed by the .primary Renderer is used as the file to be linked. The below example describes the behavior in detail. <template_extension> is the extension of the Renderer file based on the templating language it uses. For Mustache Renderer , it is .tmpl , while for Liquid Renderer , it is .liquid . Here is an example. The following template contains two Mustache Renderer files for conceptual document type: /- some_template/ |- conceptual.html.primary.tmpl \\- conceptual.mta.json.tmpl There are two Markdown files A.md and B.md , the content for A.md is: [Link To B](B.md) The template system produces two output files for A.md : A.html and A.mta.json , and also two output files for B.md : B.html and B.mta.json . According to conceptual.html.primary.tmpl , .html is the primary output file, the link from A.md to B.md is resolved to B.html instead of B.mta.json , which is to say, the content of A.md is transformed to: <a href=\"B.html\">Link To B</a> Note If no primary Renderer is defined, DocFX randomly picks one Renderer as the primary one, and the result is unpredictable. Renderer in Mustache syntax Introduction to Mustache Mustache is a logic-less template syntax containing only tag s. It works by expanding tags in a template using values provided in a hash or object. Tag s are indicated by the double mustaches. {{name}} is a tag, it tries to find the name key in current context, and replace it with the value of name . mustache.5 lists the syntax of Mustache in detail. Naming rule Renderer s in Mustache syntax MUST end with .tmpl extension. Mustache Partials Mustache Partials is also supported in the template system. Partials are common sections of Renderer that can be shared by multiple Renderer files. Partials MUST end with .tmpl.partial . For example, inside a Template , there is a Partial file part.tmpl.partial with content: Inside Partial {{ name }} To reuse this Partial file, Renderer file uses the following syntax: Inside Renderer {{ >part }} It has the same effect with the following Renderer file: Inside Renderer Inside Partial {{ name }} Extended syntax for Dependencies When rendering the input data model into output files, for example, html files, the html file may rely on other files to display correctly. For example, the html file dependents on stylesheet file main.css . We call such file main.css a Dependency to the Renderer . DocFX introduces the following syntax to define the dependency for the Renderer : {{!include('<file_name>')}} docfx copies these dependencies to output folder preserving its relative path to the Renderer file. Tip Mustache is logic-less, and for a specific {{name}} tag, Mustache searches its context and its parent context recursively. So most of the time Preprocessor File is used to re-define the data model used by the Mustache Renderer . Extended syntax for Master page In most cases templates with different document types share the same layout and style. For example, most of the pages can share navbar, header, or footer. DocFX introduces the following syntax to use a master page: {{!master('<master_page_name>')}} Inside the master page, the following syntax is used for pages to place their content body: {{!body}} For example, with the following master page _master.html : <html> <head></head> <body> {{!body}} <body> </html> A template conceptual.html.tmpl as follows: {{!master('_master.html')}} Hello World renders as the same as: <html> <head></head> <body> Hello World <body> </html> Renderer in Liquid syntax Naming rule Renderer s in Liquid syntax MUST end with .liquid extension. Liquid contains include tag to support partials, we follow the ruby partials naming convention to have _<partialName>.liquid as partial template. Extended syntax for Dependencies DocFX introduces a custom tag ref , e.g. {% ref file1 %} , to specify the resource files that current template depends on. Extended syntax for Master page DocFX introduces custom tags master and body to use master page: {% master <master_page_name> %} Inside the master page, the following syntax is used for pages to place their content body: {% body %} For example, with the following master page _master.html : <html> <head></head> <body> {% body %} <body> </html> A template conceptual.html.liquid as follows: {% master _master.html %} Hello World renders as the same as: <html> <head></head> <body> Hello World <body> </html> Preprocessor Renderer s take the input data model produced by the document processor and render them into output files. Sometimes the input data model is not exactly what the Renderer s want. The template system introduces the concept of Preprocessor to transform the input data model into exactly what the Renderers want. We call the data model returned by the Preprocessor the View Model . The View Model is the data model applied to the Renderers . Naming rule for Preprocessor The naming of the Preprocessor follows the naming of the Renderer , with file extension changes to .js : <renderer_file_name_without_extension>.js . If a Preprocessor has no corresponding Renderer , it still needs to be executed. For example, to run exports.getOptions function , it should be named as <document_type>.tmpl.js . Syntax for Preprocessor Preprocessor s are JavaScript files following ECMAScript 5.1 standard. The template system uses Jint as JavaScript Engine, and provides several additional functions for easy debugging and integration. Module Preprocessor leverages the concept of Module as similar to the Module in Node.js . The syntax of Module in Preprocessor is a subset of the one in Node.js. The advantage of the Module concept is that the Preprocessor script file can also be run in Node.js. The Module syntax in Preprocessor is simple, To export function property from one Module file common.js : exports.util = function () {} To use the exported function property inside common.js : var common = require('./common.js'); // call util common.util(); Note Only relative path starting with ./ is supported. Log You can call the following functions to log messages with different error levels: console.log , console.warn or console.warning and console.err . Function Signature A Preprocessor file is also considered as a Module. It MUST export the function property with the signature required by DocFx's prescriptive interop pattern. There are two functions defined. Function 1: exports.getOptions Function property getOptions takes the data model produced by document processor as the input argument, and the return value must be an object with the following properties: Property Name Type Description isShared bool Defines whether the input data model can be accessed by other data models when transform . By default the value is false . If it is set to true , the data model will be stored into Globally Shared Properties . A sample exports.getOptions defined in toc.tmpl.js is: exports.getOptions = function (model) { return { isShared: true; }; } Function 2: exports.transform Function property transform takes the data model produced by document processor (described in further detail in The Input Data Model ) as the input argument, and returns the View Model . View Model is the exact model to apply the corresponding Renderer . A sample exports.transform for conceptual.txt.js is: exports.transform = function (model) { model._title = \"Hello World\" return model; } If conceptual.txt.tmpl is: {{{_title}}} Then Markdown file A.md is transformed to A.txt with content: Hello World Tip For each file, the input data model can be exported to a JSON file by calling docfx build --exportRawModel . And the returned View Model can be exported to a JSON file by calling docfx build --exportViewModel . The output files are stored in the DocFx destination subdirectory, which defaults to <project-name>\\_site\\ . The Input Data Model The input data model used by transform not only contains properties extracted from the content of the file, but also system generated properties and globally shared properties. System Generated Properties System generated property names start with underscore _ , as listed in the following table: Name Description _rel The relative path of the root output folder from current output file. For example, if the output file is a/b/c.html from root output folder, then the value is ../../ . _path The path of current output file starting from root output folder. _navPath The relative path of the root TOC file from root output folder, if exists. The root TOC file stands for the TOC file in root output folder. For example, if the output file is html file, the value is toc.html . _navRel The relative path from current output file to the root TOC file, if exists. For example, if the root TOC file is toc.html from root output folder, the value is empty. _navKey The original file path of the root TOC file starting with ~/ . ~/ stands for the folder where docfx.json is in, for example, ~/toc.md . _tocPath The relative path of the TOC file that current output file belongs to from root output folder, if current output file is in that TOC file. If current output file is not defined in any TOC file, the nearest TOC file is picked. _tocRel The relative path from current output file to its TOC file. For example, if the TOC file is a/toc.html from root output folder, the value is ../ . _tocKey The original file path of the TOC file starting with ~/ . ~/ stands for the folder where docfx.json is in, for example, ~/a/toc.yml . Note Users can also override system generated properties by using YAML Header , fileMetadata or globalMetadata . Globally Shared Properties Globally shared properties are stored in __global key for every data model. Its initial value is read from global.json inside the Template if the file exists. If a data model has isShared equal to true with the above getOptions function property, it is stored in __global._shared with the original path starting with ~/ as the key."
  },
  "tutorial/intro_toc.html": {
    "href": "tutorial/intro_toc.html",
    "title": "Table-Of-Content (TOC) Files | docfx",
    "keywords": ""
  },
  "tutorial/links_and_cross_references.html": {
    "href": "tutorial/links_and_cross_references.html",
    "title": "Links and Cross References | docfx",
    "keywords": "Links and Cross References Markdown provides a syntax to create hyperlinks. For example, the following syntax: [bing](http://www.bing.com) Will render to: <a href=\"http://www.bing.com\">bing</a> Here the url in the link could be either absolute url pointing to another website ( www.bing.com in the above example), or a relative url pointing to a local resource on the same server (for example, about.html ). When working with large documentation project that contains multiple files, it is often needed to link to another Markdown file using the relative path in the source directory. Markdown spec doesn't have a clear definition of how this should be supported. What's more, there is also a common need to link to another file using a \"semantic\" name instead of its file path. This is especially common in API reference docs, for example, you may want to use System.String to link to the topic of String class, without knowing it's actually located in api/system/string.html , which is auto generated. In this document, you'll learn the functionalities DocFX provides for resolving file links and cross reference, which will help you to reference other files in an efficient way. Link to a file using relative path In DocFX, you can link to a file using its relative path in the source directory. For example, You have a file1.md under root and a file2.md under subfolder/ : / |- subfolder/ | \\- file2.md \\- file1.md You can use relative path to reference file2.md in file1.md : [file2](subfolder/file2.md) DocFX converts it to a relative path in output folder structure: <a href=\"subfolder/file2.html\">file2</a> You can see the source file name ( .md ) is replaced with output file name ( .html ). Note DocFX does not simply replace the file extension here ( .md to .html ), it also tracks the mapping between input and output files to make sure source file path will resolve to correct output path. For example, if in the above case, subfolder is renamed to subfolder2 using file mapping in docfx.json , in output html, the link url will also resolve to subfolder2/file2.html . Relative path vs. absolute path It's recommended to always use relative path to reference another file in the same project. Relative path will be resolved during build and produce build warning if the target file does not exist. Tip A file must be included in docfx.json to be processed by DocFX, so if you see a build warning about a broken link but the file actually exists in your file system, go and check whether this file is included in docfx.json . You can also use absolute path (path starts with / ) to link to another file, but DocFX won't check its correctness for you and will keep it as-is in the output HTML. That means you should use the output file path as absolute path. For example, in the above case, you can also write the link as follows: [file2](/subfolder/file2.html) Sometimes you may find it's complicated to calculate relative path between two files. DocFX also supports paths that start with ~ to represent a path relative to the root directory of your project (i.e., where docfx.json is located). This kind of path will also be validated and resolved during build. For example, in the above case, you can write the following links in file2.md : [file1](~/file1.md) [file1](../file1.md) Both will resolve to ../file1.html in output html. Warning Automatic link doesn't support relative path. If you write something like <file.md> , it will be treated as an HTML tag rather than a link. Links in file includes If you use file include to include another file, the links in the included file are relative to the included file. For example, if file1.md includes file2.md : [!include[file2](subfolder/file2.md)] All links in file2.md are relative to the file2.md itself, even when it's included by file1.md . Note Please note that the file path in include syntax is handled differently than Markdown link. You can only use relative path to specify location of the included file. And DocFX doesn't require included file to be included in docfx.json . Tip Each file in docfx.json will build into an output file. But included files usually don't need to build into individual topics. So it's not recommended to include them in docfx.json . Links in inline HTML Markdown supports inline HTML . DocFX also supports to use relative path in inline HTML. Path in HTML link ( <a> ), image ( <img> ), script ( <script> ) and css ( <link> ) will also be resolved if they're relative path. Using cross reference Besides using file path to link to another file, DocFX also allows you to give a file a unique identifier so that you can reference this file using that identifier instead of its file path. This is useful in the following cases: A path to a file is long and difficult to memorize or changes frequently. API reference documentation which is usually auto generated so it's difficult to find its file path. References to files in another project without needing to know the project's file structure. The basic syntax for cross referencing a file is: <xref:id_of_another_file> This is similar to automatic link syntax in Markdown but with a xref scheme. This link will build into: <a href=\"path_of_another_file\">title_of_another_file</a> As you can see, one benefit of using cross reference is that you don't need to specify the link text and DocFX will automatically resolve it for you. Note Title is extracted from the first heading of the Markdown file. Or you can also specify title using title metadata. Define UID The unique identifier of a file in DocFX is called a UID. For a Markdown file, you can specify its UID by adding a UID metadata in the YAML header . For example, the following Markdown defines a UID \"fileA\". --- uid: fileA --- # This is fileA ... Note UID is supposed to be unique inside a project. If you define duplicate UID for two files, the resolve result is undetermined. For API reference files, UID is auto generated by mangling the API's signature. For example, the System.String class's UID is System.String . You can open a generated YAML file to lookup the value of its UID. Note Conceptual Markdown file doesn't have UID generated by default. So it cannot be cross referenced unless you give it a UID. Different syntax of cross reference Besides the auto link, we also support some other ways to use cross references: Markdown link In Markdown link, you can also use xref in link url: [link_text](xref:uid_of_another_file) This will resolve to: <a href=\"path_of_another_file\">link_text</a> In this case, DocFX won't resolve the link text for you because you already specified it, unless the link_text is empty. Shorthand form You can also use @uid_to_another_file to quickly reference another file. There are some rules for DocFX to determine whether a string following @ are UID: The string after @ must start with [A-Za-z] , and end with: Whitespace or line end Punctuation ( [.,;:!?`~] ) followed by whitespace or line end Two or more punctuations ( [.,;:!?`~] ) A string enclosed by a pair of quotes ( ' or \" ) The render result of @ form is same as the auto link form. For example, @System.String is the same as <xref:System.String> . Warning Since @ is a common character in a document, DocFX doesn't show a warning if a UID isn't found for a shorthand form xref link. Warnings for missing links are shown for auto links and Markdown links. Using hashtag in cross reference Sometimes you need to link to the middle of a file (an anchor) rather than jump to the beginning of a file. DocFX also allows you to do that. In Markdown link or auto link, you can add a hashtag ( # ) followed by the anchor name after UID. For example: <xref:uid_to_file#anchor_name> [link_text](xref:uid_to_file#anchor_name) @uid_to_file#anchor_name Will all resolve to url_to_file#anchor_name in output HTML. The link text still resolves to the title of the whole file. If it's not what you need, you can specify your own link text. Note Hashtag in xref is always treated as separator between file name and anchor name. That means if you have # in UID, it has to be encoded to %23 . The xref format follows the URI standard so that all reserved characters should be encoded. Link to overwrite files Overwrite file itself doesn't build into individual output file. It's merged with the API reference item model to build into a single file. If you want to link to the content inside an overwrite file (for example, an anchor), you cannot use the path to the overwrite file. Instead, you should either cross reference its UID, or link to the YAML file that contains the API. For example, you have String class which is generated from system.string.yml , then you have a string.md that overwrites its conceptual part which contains a compare-strings section. You can use one of the following syntax to link to this section: [compare strings](xref:System.String#compare-strings) [compare strings](system.string.yml#compare-strings) Both will render to: <a href=\"system.string.html#compare-strings\">compare strings</a> Cross reference between projects Another common need is to reference topics from an external project. For example, when you're writing the documentation for your own .NET library, you'll want to add some links that point to types in .NET base class library. DocFX gives you two ways to achieve this functionality: by exporting all UIDs in a project into a map file to be imported in another project, and through cross reference services. Cross reference map file When building a DocFX project, there will be an xrefmap.yml generated under output folder. This file contains information for all topics that have UID defined and their corresponding urls. The format of xrefmap.yml looks like this: references: - uid: uid_of_topic name: title_of_topic href: url_of_topic.html fullName: full_title_of_topic - ... It's a YAML object that contains following properties: references : a list of topic information, each item contains following properties: uid : UID to a conceptual topic or API reference name : title of the topic href : url to the topic, which is an absolute url or relative path to current file ( xrefmap.yml ) fullName : doesn't apply to conceptual, means the fully qualified name of API. For example, for String class, its name is String and fully qualified name is System.String . This property is not used in link title resolve for now but reserved for future use. Tip The topic is not necessarily a file, it can also be a section inside a file. For example, a method in a class. In this case its url could be an anchor in a file. Using cross reference map Once you import a cross reference map file in your DocFX project, all UIDs defined in that file can be cross referenced. To use a cross reference map, add a xref config to the build section of docfx.json : { \"build\": { \"xref\": [ \"<path_to_xrefmap>\" ], ... } } The value of xref could be a string or a list of strings that contain the path/url to cross reference maps. Note DocFX supports reading cross reference map from a local file or a web location. It's recommended to deploy xrefmap.yml to the website together with topic files so that others can directly use its url in docfx.json instead of downloading it to local. Cross reference services Cross reference services are hosted services that can be queried for cross reference information. When DocFX generates the metadata for your project, it will perform cross reference lookups against the service. To use a cross reference service, add a xrefservice config to the build section of docfx.json : { \"build\": { \"xrefService\": [ \"<url_to_xrefservice>\" ], ... } } For example, the URL for the cross reference service for .NET BCL types is https://xref.docs.microsoft.com/query?uid={uid} . Advanced: more options for cross reference You can create a cross link with following options: text : the display text when the cross reference has been resolved correctly. e.g.: @\"System.String?text=string\" will be resolved as string . alt : the display text when the cross reference does not have a href property. e.g.: <xref href=\"System.Collections.Immutable.ImmutableArray`1?alt=ImmutableArray\"/> will be resolved as ImmutableArray<T> . displayProperty : the property of display text when the cross reference is has resolved correctly. e.g.: <a href=\"xref:System.String?displayProperty=fullName\"/> will be resolved as System.String . altProperty : the property of display text when the cross reference does not have a href property. e.g.: <xref href=\"System.Collections.Immutable.ImmutableArray`1\" altProperty=\"name\"/> will be resolved as ImmutableArray<T> . title : the title of link. e.g.: [](xref:System.String?title=String+Class) will be resolved as String ."
  },
  "tutorial/universalreference/gen_doc_for_js.html": {
    "href": "tutorial/universalreference/gen_doc_for_js.html",
    "title": "Generate API Documentation for JavaScript | docfx",
    "keywords": "Generate API Documentation for JavaScript 1. Prerequisite DocFX Node.js (includes npm) 2. Steps 2.1 Prepare Source Code Prepare the JavaScript source code for generating document. In this tutorial, we take azure-batch as an example npm install azure-batch 2.2 Generate Metadata We use Node2DocFX tool to generate YAML files. npm install node2docfx Create the node2docfx.json for the tool configuration: { \"source\": { \"include\": [\"node_modules/azure-batch/lib\"] }, \"destination\": \"yml\" } With this config, the tool will read source code under node_modules/azure-batch/lib , and extract metadata to YAML files under yml folder: node node_modules/node2docfx/node2docfx.js node2docfx.json 2.3 Build Document Create the configuration docfx.json for DocFX: { \"build\": { \"content\": [ { \"files\": [\"**/*.yml\"], \"src\": \"yml\", \"dest\": \"api\" } ], \"dest\": \"_site\" } } More information about docfx.json can be found in user manual . Run: docfx docfx.json --serve Now you can see your generated pages: http://localhost:8080/api/Account.html"
  },
  "tutorial/universalreference/gen_doc_for_ts.html": {
    "href": "tutorial/universalreference/gen_doc_for_ts.html",
    "title": "Generate API Documentation for TypeScript | docfx",
    "keywords": "Generate API Documentation for TypeScript 1. Prerequisite DocFX Node.js (includes npm) Git 2. Steps 2.1 Prepare Source Code Prepare the TypeScript source code for generating document. In this tutorial, we take azure-iot-device as an example. git clone https://github.com/Azure/azure-iot-sdk-node.git 2.2 Generate Metadata for a package We use typedoc tool and type2docfx to generate YAML files. First, let's install the tools globally. npm install -g typedoc type2docfx@0.10.5 2.2.1 TypeDoc to parse source code into a JSON format output Go to the folder where package.json file locate. Run typedoc --json api.json azure-iot-sdk-node/device/core/src --module commonjs --includeDeclarations --ignoreCompilerErrors --excludeExternals The parameter may differ for your needs. You can use typedoc -h to explore more options. 2.2.2 Type2docfx to extract the JSON format output into YAML files Find the output api.json file and run: type2docfx api.json yml The yml stands for the output folder, you can specify the folder as the content publishing folder in Section 2.3. And you can explore more option by type2docfx -h . With --sourceUrl, --sourceBranch, and --basePath parameters, you can generate yaml files referencing to the source code in Github, which will help developer to find the corresponding source code easily. Note All sources under node_modules path will be automatically ignored. 2.3 Build Document Create the configuration docfx.json for DocFX: { \"build\": { \"content\": [ { \"files\": [\"**/*.yml\"], \"src\": \"yml\", \"dest\": \"api\" } ], \"dest\": \"_site\" } } More information about docfx.json can be found in user manual . Run: docfx docfx.json --serve Now you can see your generated pages: http://localhost:8080/api/azure-iot-device/Client.html#azure_iot_device_Client 3. Know issues Some types can't link to the property correctly now. They displays in plain text and prefixed with @ ."
  },
  "tutorial/universalreference/intro_multiple_langs_support.html": {
    "href": "tutorial/universalreference/intro_multiple_langs_support.html",
    "title": "Introduction to Multiple Languages Support | docfx",
    "keywords": "Introduction to Multiple Languages Support 1. Introduction DocFX supports generating API documentation for C# and VB natively. However, it's not limited to these. DocFX is designed to support any language. When generating documents for a language, two steps are required: generating metadata and building documents from the metadata. 2. Workflow 2.1 Generate Metadata As different programming language has different tool written with different language to generate API documentation, this step is not included in DocFX core. We call the tool used as Metadata Tool . As UniversalReferenceDocumentProcessor is used to process these metadata files, the metadata tool should generate files according the processor's input schema. The files should: be in YAML format and end with .yml or .yaml have YamlMime ### YamlMime:UniversalReference as the first line conform to the data model defined for UniversalReference Usually, a TOC should be generated along with YAML files for easy navigation among files. 2.2 Build Document The YAML files generated are used as input to DocFX. DocFX will build these YAML files into HTML pages. 3. Supported Languages JavaScript TypeScript Python (coming soon ...)"
  },
  "tutorial/validate_your_markdown_files.html": {
    "href": "tutorial/validate_your_markdown_files.html",
    "title": "Validate Markdown files | docfx",
    "keywords": "Validate Markdown files In Markdown, it is possible to write any type of content, as long as the used syntax is valid. For example, Markdown supports the direct use of HTML tags - one can use the <h1>title</h1> syntax instead of conventional Markdown, such as #title . With full-fledged HTML support, some behaviors might not be desirable. For example, you may not want to allow <script> tags included in Markdown, as that can introduce arbitrary JavaScript into documentation. In this document, you'll learn how to define Markdown validation rules, which will help you ensure that your document follows strict conventions. Note Markdown validation is part of the dfm Markdown processor in DocFX. If you switch the Markdown engine, validation rules might not apply the same way. There are three kinds of validation rules provided by DocFX: HTML tag rules . Used to validate HTML tags in Markdown content. There is often a need to restrict usage of HTML tags in Markdown to only allow safe markup. Markdown token rules . This rule type can be used to validate different kinds of Markdown syntax elements, such as headings, links or images. Metadata rules . This rule type can be used to validate document metadata. Metadata can be defined in the YAML header in individual Markdown files, the docfx.json configuration file, or a standalone JSON file. Metadata rules give you a central place to validate metadata against specific document tagging conventions. HTML tag validation rules In most cases, there is a need to limit the use of specific HTML tags in Markdown files. This is helpful in ensuring that the content is consistent and follows a documentation standard that is applicable to your project or organization. To define a new HTML tag rule, create a md.style file with content similar to the snippet below: { \"tagRules\": [ { \"tagNames\": [ \"H1\", \"H2\" ], \"relation\": \"In\", \"behavior\": \"Warning\", \"messageFormatter\": \"Please do not use <H1> and <H2>, use '#' and '##' instead.\", \"customValidatorContractName\": null, \"openingTagOnly\": false } ] } With this rule in place, anytime a <H1> or <H2> tag is used in a Markdown file, the DocFX build will produce a warning. You can use the following properties to configure the HTML tag rule: Property Description tagNames The list of HTML tag names to validate, required , case-insensitive . relation Optional for tagNames . Possible values: In - when HTML tag is in tagNames , this is default value. NotIn - when HTML tag is not in tagNames . behavior ( Required ) Defines the behavior for when the HTML tag rule is triggered. Possible values: None - Do nothing. Warning - Log a warning. Error - Log an error and stop the build. messageFormatter ( Required ) The log message displayed in the build output when the rule is triggered. Can contain the following variables: {0} - the name of tag. {1} - the whole tag. For example, the messageFormatter can be set to {0} is the tag name of {1}. . When the <H1 class=\"heading\"> string will trigger the rule, the build output will contain: H1 is the tag name of <H1 class=\"heading\">. customValidatorContractName An optional extension tag rule contract name for complex validation rules. See Create a custom HTML tag rule for details on creating custom rules. openingTagOnly Optional Boolean value that determines whether the document is scanned for opening tags only, or whether closing tags are required. Default is false . Testing the rule To enable and test the newly-created rule, place the md.style file in the same folder where docfx.json is located, then run docfx . If you followed the example above, a warning will be shown if <H1> or <H2> tags are encountered during build. Create a custom HTML tag rule By default HTML tag rules only validate whether a HTML tag exists in Markdown files. In certain scenarios it might be important to validate the contents of the tag in addition to its presence. For example, you may not want a tag to contain onclick attributes, as that can result in injected JavaScript on the documentation page. To perform tag content validation, it is possible to create a custom rule. To do so, follow the steps below. Create a new .NET project in your code editor (e.g. Visual Studio). Add a reference to the Microsoft.DocAsCode.Plugins and Microsoft.Composition NuGet packages. Create a new class and implement the @Microsoft.DocAsCode.Plugins.ICustomMarkdownTagValidator interface. Add the ExportAttribute decorator with your contract name. For example, to require for HTML links ( <a> ) to not include the onclick attribute, the code can be written as such: [Export(\"should_not_contain_onclick\", typeof(ICustomMarkdownTagValidator))] public class MyMarkdownTagValidator : ICustomMarkdownTagValidator { public bool Validate(string tag) { // use Contains for demo purpose, a complete implementation should parse the HTML tag. return tag.Contains(\"onclick\"); } } Build the project, to make sure that you have an assembly that contains the compiled contract. Subsequently, the md.style file can be updated with a reference to the contract, as specified in code: { \"tagRules\": [ { \"tagNames\": [ \"a\" ], \"behavior\": \"Warning\", \"messageFormatter\": \"Please do not use 'onclick' in HTML link.\", \"customValidatorContractName\": \"should_not_contain_onclick\", \"openingTagOnly\": true } ] } Integrating the custom rule into the build Just as it's done for built-in HTML tag rules, configure the rule in the md.style file. Create a new folder in your DocFX project directory ( rules , for example) and place all your custom rule assemblies to a plugins folder under the rules directory. Your DocFX project should look like this: / |- docfx.json |- md.style \\- rules \\- plugins \\- <your_rule>.dll Update your docfx.json to include a reference to the rules folder: { ... \"dest\": \"_site\", \"template\": [ \"default\", \"rules\" ] } Run docfx in your project folder. New rules will be executed and the build output will capture any triggers. Note The rules folder is a template folder. In DocFX, templates are a place to customize the build, rendering and validation behaviors. For more information about templates, please refer to our template documentation and plugin documentation . Markdown token validation rules Besides HTML tags, you may also want to validate Markdown syntax like headings or links. This is helpful if you want to implement scenarios such as limiting code snippets to only support a set of pre-defined programming language identifiers. To create a rule, follow the steps below: Create a new project in your IDE (e.g. Visual Studio). Add a reference to the Microsoft.DocAsCode.MarkdownLite and Microsoft.Composition NuGet packages. Create a class that implements the @Microsoft.DocAsCode.MarkdownLite.IMarkdownTokenValidatorProvider interface. @Microsoft.DocAsCode.MarkdownLite.MarkdownTokenValidatorFactory contains some helper methods to create a validator. Decorate your class with the ExportAttribute , that contains the rule name. For example, the following rule will require all code blocks to use the csharp language identifier: [Export(\"code_snippet_should_be_csharp\", typeof(IMarkdownTokenValidatorProvider))] public class MyMarkdownTokenValidatorProvider : IMarkdownTokenValidatorProvider { public ImmutableArray<IMarkdownTokenValidator> GetValidators() { return ImmutableArray.Create( MarkdownTokenValidatorFactory.FromLambda<MarkdownCodeBlockToken>(t => { if (t.Lang != \"csharp\") { throw new DocumentException($\"Code lang {t.Lang} is not valid, in file: {t.SourceInfo.File}, at line: {t.SourceInfo.LineNumber}\"); } })); } } To enable this rule, update your md.style with the following rule flag: { \"rules\": [ \"code_snippet_should_be_csharp\" ] } Follow the steps in How to enable custom HTML tag rules to configure the plugin and run docfx in the project folder. You'll see your rule picked up by the build. Logging in your rules You can throw @Microsoft.DocAsCode.Plugins.DocumentException to raise an error with the rules. This will stop the build immediately. You can also use @Microsoft.DocAsCode.Common.Logger.LogWarning(System.String,System.String,System.String,System.String) and @Microsoft.DocAsCode.Common.Logger.LogError(System.String,System.String,System.String,System.String) to report a warning or an error, respectively. Note To use the aforementioned methods, you will need to install the Microsoft.DocAsCode.Common NuGet package. The difference between LogError and throwing DocumentException is in the fact that throwing the exception will stop the build immediately. LogError won't stop the build but will report a failure once the rest of the execution is complete. Advanced: validating tokens with file context In certain cases, we might need to validate tokens with the file context. For example, it might be necessary to enforce a rule that ensures that each topic has one title (i.e. H1 written in standard Markdown syntax, e.g. # <title> ). You can't directly count the tokens with @Microsoft.DocAsCode.MarkdownLite.IMarkdownTokenValidator since the context is shared by all files - the rule will never be hit when there is no heading in a file. We can create a custom validator as such: MarkdownTokenValidatorFactory.FromLambda<MarkdownHeadingBlockToken>( t => { if (t.Depth == 1) { var re = MarkdownTokenValidatorContext.CurrentRewriteEngine; var h1Count = (int)re.GetVariable(\"h1Count\"); re.SetVariable(\"h1Count\", h1Count + 1); } }, re => { re.SetVariable(\"h1Count\", 0); re.SetPostProcess(\"checkH1Count\", re1 => { var h1Count = (int)re.GetVariable(\"h1Count\"); if (h1Count != 1) { Logger.LogError($\"Unexpected title count: {h1Count}.\"); } }) }); The FromLambda method takes two callbacks: The first callback will be invoked in @Microsoft.DocAsCode.MarkdownLite.MarkdownHeadingBlockToken, matched against all files. The static @Microsoft.DocAsCode.MarkdownLite.MarkdownTokenValidatorContext.CurrentRewriteEngine property will provide current context object. The second callback will be invoked when starting the processing of a new file. You can initialize some variables for each file, and register some callbacks when the file processing is complete. Advanced usage of md.style Default rules If a rule has the default contract name, it will be enabled by default. You don't need to enable it in md.style . Enable/disable rules in md.style You can use the disable property to specify whether a rule needs to be disabled: { \"rules\": [ { \"contractName\": \"<contract_name>\", \"disable\": true } ] } This gives you an opportunity to disable the rules enabled by default. Validate metadata in Markdown files In Markdown files, we can write metadata in the YAML header or an overwrite document . DocFX allows you to create a plug-in to validate metadata. Scope of metadata validation Metadata will be validated by the DocFX build in the following order: YAML header in the Markdown file. Global metadata and file metadata in docfx.json . Global metadata and file metadata defined in separate .json files. Tip For more information about global metadata, check out the documentation on docfx.json . Create validation plug-ins Create a new project in your IDE (e.g. Visual Studio). Add a reference to Microsoft.DocAsCode.Plugins and Microsoft.Composition NuGet packages. Create a new class and implement the @Microsoft.DocAsCode.Plugins.IInputMetadataValidator. For example, the following validator prohibits any metadata with the name set to hello : [Export(typeof(IInputMetadataValidator))] public class MyInputMetadataValidator : IInputMetadataValidator { public void Validate(string sourceFile, ImmutableDictionary<string, object> metadata) { if (metadata.ContainsKey(\"hello\")) { throw new DocumentException($\"Metadata 'hello' is not allowed, file: {sourceFile}\"); } } } Enable the metadata rule the same way as outlined above - copy the compiled assemblies to the plugins directory in your project and run docfx . Create configurable metadata validation plug-ins There are two steps to create a metadata validator: Modify the ExportAttribute for the metadata validator plug-in class to specify its type: [Export(\"hello_is_not_valid\", typeof(IInputMetadataValidator))] Note If the rule doesn't have a contract name, it will be always enabled, i.e. there is no way to disable it unless the assembly files are deleted. Modify the md.style file with the following content: { \"metadataRules\": [ { \"contractName\": \"hello_is_not_valid\", \"disable\": false } ] } Advanced: Sharing your rules Some users might have a number of documentation projects, and may want to share validation rules between them. In such a scenario, writing md.style files repeatedly is sub-optimal. Create a template For this propose, we can create a template with following structure: / (root folder for plug-in) \\- md.styles |- <category-1>.md.style \\- <category-2>.md.style \\- plugins \\- <your_rule>.dll The md.styles folder will contain a set of definition files, with the file extension set to .md.style ( each file is a category ). Each category file contains a set of rule definitions. For example, you can create a test.md.style file, then include the following rules: { \"tagRules\": { \"heading\": { \"tagNames\": [ \"H1\", \"H2\" ], \"behavior\": \"Warning\", \"messageFormatter\": \"Please do not use <H1> and <H2>, use '#' and '##' instead.\", \"openingTagOnly\": true } }, \"rules\": { \"code\": \"code_snippet_should_be_csharp\" }, \"metadataRules\": { \"hello\": { \"contractName\": \"hello_is_not_valid\", \"disable\": true } } } test is the category name ( taken from file name ) for three rules. A different identifier is applied for each rule - heading , code and hello . When you build your documentation with this template, all aforementioned rules will be active when the disable property is set to false . Config rules Some rules need to be enabled or disabled in certain documentation projects. For example, the hello rule might not be required for most of your projects, but for others it might be necessary. To configure this scenario, you will need to modify the md.style file in your document project with the following settings: { \"settings\": [ { \"category\": \"test\", \"id\": \"hello\", \"disable\": false } ] } And for other projects, you will need to disable all rules in test category: { \"settings\": [ { \"category\": \"test\", \"disable\": true } ] } Note The disable property is applied in the following order: tagRules , rules and metadataRules in md.style . Automatically enabled rules with contract names set to default . settings with category and id in md.style . settings with category in md.style . disable property in definition file."
  },
  "tutorial/walkthrough/advanced_walkthrough.html": {
    "href": "tutorial/walkthrough/advanced_walkthrough.html",
    "title": "Walkthrough Advanced: Customize Your Website | docfx",
    "keywords": ""
  },
  "tutorial/walkthrough/walkthrough_create_a_docfx_project_2.html": {
    "href": "tutorial/walkthrough/walkthrough_create_a_docfx_project_2.html",
    "title": "Walkthrough Part II: Adding API Documentation to the Website | docfx",
    "keywords": ""
  },
  "tutorial/walkthrough/walkthrough_create_a_docfx_project.html": {
    "href": "tutorial/walkthrough/walkthrough_create_a_docfx_project.html",
    "title": "Walkthrough Part I: Generate a Simple Documentation Website | docfx",
    "keywords": ""
  },
  "tutorial/walkthrough/walkthrough_generate_pdf.html": {
    "href": "tutorial/walkthrough/walkthrough_generate_pdf.html",
    "title": "Walkthrough Part III: Generate PDF Documentation | docfx",
    "keywords": ""
  },
  "tutorial/walkthrough/walkthrough_overview.html": {
    "href": "tutorial/walkthrough/walkthrough_overview.html",
    "title": "Walkthrough Overview | docfx",
    "keywords": ""
  }
}